operation type::Assosiation  check(){
        if (self.type.toString() == "Many2Many" ){
	        for (link in self.links){
	             if (not link.masterField.pk){
	                throw "Assosiation between type "+ self.source.name + " and "+self.target.name+" has wrong assosiation. Master field has to be primary key ";
	             }
	             if (not link.detailField.pk){
	                throw "Assosiation between type "+ self.source.name + " and "+self.target.name+" has wrong assosiation. Detail field  has to be primary key   ";
	             }
	        }  
        }else{
	        for (link in self.links){
	             if (not link.masterField.pk){
	                throw "Assosiation between type "+ self.source.name + " and "+self.target.name+" has wrong assosiation. Master field has to be primary key ";
	             }
	             if (link.detailField.pk){
	                throw "Assosiation between type "+ self.source.name + " and "+self.target.name+" has wrong assosiation. Detail field should not be primary key  ";
	             }
	        }  
        }
}

operation type::Assosiation  sourceSideNamesCalculation(){
   var util = new Native('org.tura.metamodel.commons.Util');

    var target = self.target;
    if (target.isKindOf(type::TypeReference )){
         target = target.typeRef;
    }
     var sourceMethodName = util.mergeAndCapitalize(target.name);

     if (self.sourceOperation.isDefined()){
         sourceMethodName = util.mergeAndCapitalize(self.sourceOperation);
      }
     var sourceProperty =  util.mergeAndUnCapitalize(sourceMethodName);
  
    var source = self.source;
    if (source.isKindOf(type::TypeReference )){
         source = source.typeRef;
    }
    var targetMethodName = util.mergeAndCapitalize(source.name);

     if (self.targetOperation.isDefined())
         sourceMethodName = util.mergeAndCapitalize(self.targetOperation);
     var targetProperty =  util.mergeAndUnCapitalize(targetMethodName);

     var hash = new Native('java.util.HashMap');
     hash.put("sourceMethodName",sourceMethodName);
     hash.put("sourceProperty",sourceProperty);
     hash.put("targetMethodName",targetMethodName);
     hash.put("targetProperty",targetProperty);
     hash.put("target",target);

      return hash;
}

operation type::Assosiation  targetSideNamesCalculation(){
   var util = new Native('org.tura.metamodel.commons.Util');

    var source = self.source;
    if (source.isKindOf(type::TypeReference )){
         source = source.typeRef;
    }
  
   var suffix ="";
   if (self.source.uid = self.target.uid){
      suffix = "Master";
   }
  
     var targetMethodName = util.mergeAndCapitalize(source.name+suffix);
     if (self.targetOperation.isDefined())
         sourceMethodName = util.mergeAndCapitalize(self.targetOperation);
     var targetProperty =  util.mergeAndUnCapitalize(targetMethodName);
  
     var target = self.target;
     if (target.isKindOf(type::TypeReference )){
         target = target.typeRef;
     }
  
     var sourceMethodName = util.mergeAndCapitalize(target.name);
     if (self.sourceOperation.isDefined())
         sourceMethodName = util.mergeAndCapitalize(self.sourceOperation);
     var sourceProperty =  util.mergeAndUnCapitalize(sourceMethodName);

     var hash = new Native('java.util.HashMap');
     hash.put("sourceMethodName",sourceMethodName);
     hash.put("sourceProperty",sourceProperty);
     hash.put("targetMethodName",targetMethodName);
     hash.put("targetProperty",targetProperty);
     hash.put("source",source);
     hash.put("target",target);

      return hash;

}