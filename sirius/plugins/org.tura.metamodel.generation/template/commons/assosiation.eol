 operation type::TypeElement collectType(typeCollection,model_mapper,skattr,pk){
    var tp = self;
    var util = new Native('org.tura.metamodel.commons.Util');

    if (self.isTypeOf(type::TypeReference)){
        tp = self.typeRef;
    }
    if (typeCollection.contains(tp)){
        return;
    }
    
    typeCollection.add(tp);
    
    var skipAttributes=skattr;
    if (skattr == null){
        skipAttributes=new Native('java.util.ArrayList');
    }
    
    var primaryKey=pk;
    if (pk == null){
        primaryKey=new Native('java.util.ArrayList');
        self.~primaryKey = primaryKey;
    }

     for(field in tp.attributes){
        if (field.pk){
            primaryKey.add(field);
        }
     }

     var assosiations = type::Assosiation.allInstances()->select(t|t.source.uid = tp.uid  and t.source.uid <> t.target.uid);
     for (rel in assosiations){
        rel.check(); 
  	    var tp1 =  rel.target;
	    if (tp1.isKindOf(type::TypeReference )){
	        tp1 = tp1.typeRef;
	    }
	    tp1.collectType(typeCollection,model_mapper,null,null);
     }


     var assosiations = type::Assosiation.allInstances()->select(t|t.target.uid = tp.uid  and t.source.uid <> t.target.uid);
     for (rel in assosiations){
        rel.check(); 
  	    var tp1 =  rel.source;
	    if (tp1.isKindOf(type::TypeReference )){
	        tp1 = tp1.typeRef;
	    }
	    tp1.collectType(typeCollection,model_mapper,null,null);
     }

     var assosiations = type::Assosiation.allInstances()->select(t|t.target.uid = tp.uid and (t.type.toString() = "One2One" or t.type.toString() = "One2Many"));
     for (rel in assosiations){

         for (lnk in rel.links){
             skipAttributes.add(lnk.detailField);
         }
     }           
    self.~skipAttributes=skipAttributes;
    
    var extension = type::Generalization.allInstances()->select(t|t.source.uid = tp.uid  and t.classifiers->size() = 0 ).first();
    if (extension <> null){
	   var ex =  extension.target;
	   if (ex.isKindOf(type::TypeReference )){
	       ex = extension.target.typeRef;
	   }
	   ex.collectType(typeCollection,model_mapper,skipAttributes,primaryKey);
	   tp.~extension = ex;
    }
 }
 

operation type::Assosiation  check(){
        if (self.type.toString() == "Many2Many" ){
	        for (link in self.links){
	             if (not link.masterField.pk){
	                throw "Assosiation between type "+ self.source.name + " and "+self.target.name+" has wrong assosiation. Master field has to be primary key ";
	             }
	             if (not link.detailField.pk){
	                throw "Assosiation between type "+ self.source.name + " and "+self.target.name+" has wrong assosiation. Detail field  has to be primary key   ";
	             }
	        }  
        }else{
	        for (link in self.links){
	             if (not link.masterField.pk){
	                throw "Assosiation between type "+ self.source.name + " and "+self.target.name+" has wrong assosiation. Master field has to be primary key ";
	             }
	             if (link.detailField.pk){
	                throw "Assosiation between type "+ self.source.name + " and "+self.target.name+" has wrong assosiation. Detail field should not be primary key  ";
	             }
	        }  
        }
}

operation type::Assosiation  sourceSideNamesCalculation(){
   var util = new Native('org.tura.metamodel.commons.Util');

    var target = self.target;
    if (target.isKindOf(type::TypeReference )){
         target = target.typeRef;
    }
     var sourceMethodName = util.mergeAndCapitalize(target.name);

     if (self.sourceOperation.isDefined()){
         sourceMethodName = util.mergeAndCapitalize(self.sourceOperation);
      }
     var sourceProperty =  util.mergeAndUnCapitalize(sourceMethodName);
  
    var source = self.source;
    if (source.isKindOf(type::TypeReference )){
         source = source.typeRef;
    }
    var targetMethodName = util.mergeAndCapitalize(source.name);

     if (self.targetOperation.isDefined())
         sourceMethodName = util.mergeAndCapitalize(self.targetOperation);
     var targetProperty =  util.mergeAndUnCapitalize(targetMethodName);

     var hash = new Native('java.util.HashMap');
     hash.put("sourceMethodName",sourceMethodName);
     hash.put("sourceProperty",sourceProperty);
     hash.put("targetMethodName",targetMethodName);
     hash.put("targetProperty",targetProperty);
     hash.put("target",target);

      return hash;
}

operation type::Assosiation  targetSideNamesCalculation(){
   var util = new Native('org.tura.metamodel.commons.Util');

    var source = self.source;
    if (source.isKindOf(type::TypeReference )){
         source = source.typeRef;
    }
  
   var suffix ="";
   if (self.source.uid = self.target.uid){
      suffix = "Master";
   }
  
     var targetMethodName = util.mergeAndCapitalize(source.name+suffix);
     if (self.targetOperation.isDefined())
         sourceMethodName = util.mergeAndCapitalize(self.targetOperation);
     var targetProperty =  util.mergeAndUnCapitalize(targetMethodName);
  
     var target = self.target;
     if (target.isKindOf(type::TypeReference )){
         target = target.typeRef;
     }
  
     var sourceMethodName = util.mergeAndCapitalize(target.name);
     if (self.sourceOperation.isDefined())
         sourceMethodName = util.mergeAndCapitalize(self.sourceOperation);
     var sourceProperty =  util.mergeAndUnCapitalize(sourceMethodName);

     var hash = new Native('java.util.HashMap');
     hash.put("sourceMethodName",sourceMethodName);
     hash.put("sourceProperty",sourceProperty);
     hash.put("targetMethodName",targetMethodName);
     hash.put("targetProperty",targetProperty);
     hash.put("source",source);
     hash.put("target",target);

      return hash;

}