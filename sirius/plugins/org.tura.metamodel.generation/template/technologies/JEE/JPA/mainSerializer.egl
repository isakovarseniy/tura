<#assign percent = "%" >
<#assign start = "[" >
<#assign end = "]" >
${start}${percent} 
import "platform:/plugin/org.tura.metamodel.generation/template/commons/typeElementUtil.eol";
import "platform:/plugin/org.tura.metamodel.generation/template/commons/categorizedUtil.eol";

 ${percent}${end}
 
 
  [%
     var util = new Native('org.tura.metamodel.commons.Util');
     var alltypes = new Native('java.util.ArrayList');
     var hash = new Native('java.util.HashMap');
     var typeHash = new Native("java.util.HashMap"); 

     var f = new Native("org.tura.metamodel.generation.JavaFormatter"); 

     var types = util.runQuery(model_mapper,"Query model classes",model_mapper);
 
      if (types <> null and types.size <> 0 ){
        var typeCollection = new Native("java.util.ArrayList"); 
	    for (type in types){
	       type.collectType(typeCollection,model_mapper,null,null);
	    }

	    
      for(type in typeCollection){
         type.mappingType2Java(recipe,ingredient,'MODEL');
         typeHash.put(type.~fullName,type);
      }	    
 
      var path = component.getComponentRoot+"/"+component.getArtifactId()+"/src/main/java/";  
      for(type in typeHash.values()){
         
        if (not type.~primaryKey.isDefined()  ){
           continue;
        }
        //We need to map it agein to  override possible modification from "serializer.egl" template
        type.mappingType2Java(recipe,ingredient,'MODEL');

	    hash.put("package",type.~package);
	    hash.put("class",type.~class);
	    hash.put("fullName",type.~fullName);

	    hash.put("type",type);
	    hash.put("recipe",recipe);
	    hash.put("ingredient",ingredient);
	    hash.put("component",component);
	    hash.put("model_mapper",model_mapper);
	    hash.put("path",path);
		    
	    util.populateTechnologies(hash,model_mapper);
		
	    var serializer : Template = util.loadTemplate("platform:/plugin/org.tura.metamodel.generation/template/technologies/JEE/JPA/serializer.egl",hash,TemplateFactory);
	    serializer.setFormatter(f);
	    var buffer = serializer.process();
	    util.saveFile( path+hash.get("package").replaceAll("\\.","\\/"), hash.get("class")+"Serializer.java",buffer);   
         
        var allRel = new Native('java.util.ArrayList');
 		var assosiations = type::Assosiation.allInstances()->select(t|t.source.uid = type.uid);
 		allRel.addAll(assosiations);
 		assosiations = type::Assosiation.allInstances()->select(t|t.target.uid = type.uid);
 		allRel.addAll(assosiations);
 		
 		for ( rel in allRel  ){
	       if ( rel.findClassifier(util.getHint(model_mapper,"No Assosiation"))){
	              continue;
	       }
 		   rel.source.mappingType2Java(recipe,ingredient,'VIEW');
 		   rel.target.mappingType2Java(recipe,ingredient,'VIEW');

	       hash.put("rel",rel);
 		
		   var rule : Template = util.loadTemplate("platform:/plugin/org.tura.metamodel.generation/template/technologies/JEE/JPA/serializerRule.egl",hash,TemplateFactory);
		   rule.setFormatter(f);
		   var buffer = rule.process();
		   
		   util.saveFile( path+rel.source.~package.replaceAll("\\.","\\/"), rel.source.~class + rel.type.toString() +rel.target.~class+"SerializerRule.java",buffer);   
 		
 		}
         
      }
 
   }
 
 
 operation type::TypeElement collectType(typeCollection,model_mapper,skattr,pk){
    var tp = self;
    var util = new Native('org.tura.metamodel.commons.Util');

    if (self.isTypeOf(type::TypeReference)){
        tp = self.typeRef;
    }
    if (typeCollection.contains(tp)){
        return;
    }
    
    typeCollection.add(tp);
    
    var skipAttributes=skattr;
    if (skattr == null){
        skipAttributes=new Native('java.util.ArrayList');
    }
    
    var primaryKey=pk;
    if (pk == null){
        primaryKey=new Native('java.util.ArrayList');
        self.~primaryKey = primaryKey;
    }

     for(field in tp.attributes){
        if (field.pk){
            primaryKey.add(field);
        }
     }

     var assosiations = type::Assosiation.allInstances()->select(t|t.source.uid = tp.uid  and t.source.uid <> t.target.uid);
     for (rel in assosiations){
         if ( rel.findClassifier(util.getHint(model_mapper,"No Assosiation"))){
                continue;
         }
  	    var tp1 =  rel.target;
	    if (tp1.isKindOf(type::TypeReference )){
	        tp1 = tp1.typeRef;
	    }
	    tp1.collectType(typeCollection,model_mapper,null,null);
     }


     var assosiations = type::Assosiation.allInstances()->select(t|t.target.uid = tp.uid  and t.source.uid <> t.target.uid);
     for (rel in assosiations){
         if ( rel.findClassifier(util.getHint(model_mapper,"No Assosiation"))){
                continue;
         }
  	    var tp1 =  rel.source;
	    if (tp1.isKindOf(type::TypeReference )){
	        tp1 = tp1.typeRef;
	    }
	    tp1.collectType(typeCollection,model_mapper,null,null);
     }

     var assosiations = type::Assosiation.allInstances()->select(t|t.target.uid = tp.uid and (t.type.toString() = "One2One" or t.type.toString() = "One2Many"));
     for (rel in assosiations){
         if ( rel.findClassifier(util.getHint(model_mapper,"No Assosiation"))){
                continue;
         }
         for (lnk in rel.links){
             skipAttributes.add(lnk.detailField);
         }
     }           
    self.~skipAttributes=skipAttributes;
    
    var extension = type::Generalization.allInstances()->select(t|t.source.uid = tp.uid  and t.classifiers->size() = 0 ).first();
    if (extension <> null){
	   var ex =  extension.target;
	   if (ex.isKindOf(type::TypeReference )){
	       ex = extension.target.typeRef;
	   }
	   ex.collectType(typeCollection,model_mapper,skipAttributes,primaryKey);
	   tp.~extension = ex;
    }
 }
 
%]