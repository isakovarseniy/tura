[%
 import "platform:/plugin/org.tura.metamodel.generation/template/commons/typeElementUtil.eol";
 import "platform:/plugin/org.tura.metamodel.generation/template/commons/categorizedUtil.eol";
 
 var util = new Native('org.tura.metamodel.commons.Util');
 %]
package [%=rel.source.~package%];  

public class [%=rel.source.~class%][%=rel.type.toString()%][%=rel.target.~class%]SerializerRule implements org.tura.platform.repository.core.Rule {

      private [%=rel.source.~fullName%] source;
      private [%=rel.target.~fullName%] target;
      
      public void setSource([%=rel.source.~fullName%] source){
         this.source = source;
      }

      public void setTarget([%=rel.target.~fullName%] target){
         this.target = target;
      }
      
      public String getKey(){
		  StringBuffer key = new StringBuffer();
		  [%for ( field in rel.source.~primaryKey){%]
		   key.append(source.get[%=util.mergeAndCapitalize(field.name)%]());
		   [%}%]
		  key.append("[%=rel.source.~fullName%]");

		  [%for ( field in rel.target.~primaryKey){%]
		   key.append(target.get[%=util.mergeAndCapitalize(field.name)%]());
		   [%}%]
		  key.append("[%=rel.target.~fullName%]");
		  
		  return key.toString();
      }

      public void execute(){
      [%
      
 		        var target = rel.target;
			    if (target.isKindOf(type::TypeReference )){
			         target = target.typeRef;
			    }
		        var sourceMethodName = util.mergeAndCapitalize(target.name);
		
		        if (rel.sourceOperation.isDefined())
		             sourceMethodName = util.mergeAndCapitalize(rel.sourceOperation);
		        var sourceProperty =  util.mergeAndUnCapitalize(sourceMethodName);
		      
		        var source = rel.source;
			    if (source.isKindOf(type::TypeReference )){
			         source = source.typeRef;
			    }
		        var targetMethodName = util.mergeAndCapitalize(source.name);
		
		         if (rel.targetOperation.isDefined())
		             sourceMethodName = util.mergeAndCapitalize(rel.targetOperation);
		         var targetProperty =  util.mergeAndUnCapitalize(targetMethodName);
      
		  	     switch  (rel.type.toString()){
		         case "One2One" : %]     source.set[%=sourceMethodName%](target);[%
		         case "One2Many" : %]   source.get[%=sourceMethodName%]().add(target);[%
		         case "Many2Many" : %] source.get[%=sourceMethodName%]().add(target);[%
		         }           
		         

		        var source = rel.source;
			    if (source.isKindOf(type::TypeReference )){
			         source = source.typeRef;
			    }
		      
		       var suffix ="";
		       if (rel.source.uid = rel.target.uid){
		          suffix = "Master";
       		   }
       		      
		         var targetMethodName = util.mergeAndCapitalize(source.name+suffix);
		         if (rel.targetOperation.isDefined())
		             sourceMethodName = util.mergeAndCapitalize(rel.targetOperation);
		         var targetProperty =  util.mergeAndUnCapitalize(targetMethodName);
		      
		         var target = rel.target;
			     if (target.isKindOf(type::TypeReference )){
			         target = target.typeRef;
			     }
		      
		         var sourceMethodName = util.mergeAndCapitalize(target.name);
		         if (rel.sourceOperation.isDefined())
		             sourceMethodName = util.mergeAndCapitalize(rel.sourceOperation);
		         var sourceProperty =  util.mergeAndUnCapitalize(sourceMethodName);
		         
		         
		  	     switch  (rel.type.toString()){
		         case "One2One" : %]  target.se[%=targetMethodName%](source);[%
		         case "One2Many" : %] target.set[%=targetMethodName%](source);[%
		         case "Many2Many" : %] target.get[%=targetMethodName%]().add(source);[%
		         }                
		              
      %]
      }



}
 