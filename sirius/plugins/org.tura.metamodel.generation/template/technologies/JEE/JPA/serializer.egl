[%
 import "platform:/plugin/org.tura.metamodel.generation/template/commons/typeElementUtil.eol";
 import "platform:/plugin/org.tura.metamodel.generation/template/commons/categorizedUtil.eol";
 import "platform:/plugin/org.tura.metamodel.generation/template/commons/assosiation.eol";
  
 var util = new Native('org.tura.metamodel.commons.Util');
 %]
package [%=package%];  

public class [%=class%]Serializer {

     javax.persistence.EntityManager em;
     public void setEntityManager(javax.persistence.EntityManager em){
           this.em=em;
     }
      

       [% 
         var tp = type;
         tp.mappingType2Java(recipe,ingredient,"VIEW");
       %]
       public [%=tp.~fullName%]  load([%=fullName%] jpa, java.util.HashMap<String,Object> context,java.util.HashMap<String,org.tura.platform.repository.core.Rule> connections){

        [%=stringPK(tp,"key","jpa",fullName)%]
       
        [%=tp.~fullName%] obj = new [%=tp.~fullName%]();
        context.put(key.toString(),obj);
        [%
         while  (1 == 1) {
         %]
          [%=serializer(tp,type.~skipAttributes,"jpa","obj")%]
         [%  
		     var assosiations = type::Assosiation.allInstances()->select(t|t.source.uid = tp.uid);
		     for (rel in assosiations){
		         if ( rel.findClassifier(util.getHint(model_mapper,"No Assosiation"))){
		                continue;
		         }
                rel.target.mappingType2Java(recipe,ingredient,"VIEW");
                var serializer = rel.target.~fullName+"Serializer";


                rel.target.mappingType2Java(recipe,ingredient,"MODEL");
                rel.source.mappingType2Java(recipe,ingredient,"MODEL");

                var hash = rel.sourceSideNamesCalculation();
		         
		  	     switch  (rel.type.toString()){
		         case "One2One" : %]  [%=hash.get("target").~fullName%]  target[%=hash.get("sourceMethodName")%] =  jpa.get[%=hash.get("sourceMethodName")%]();[%
		         case "One2Many" : %] java.util.Collection<[%=hash.get("target").~fullName%]>  targets[%=hash.get("sourceMethodName")%] =   jpa.get[%=hash.get("sourceMethodName")%]();[%
		         case "Many2Many" : %] java.util.Collection<[%=hash.get("target").~fullName%]>  targets[%=hash.get("sourceMethodName")%] =   jpa.get[%=hash.get("sourceMethodName")%]();[%
		         }                

                 var suffix="";
                 var r = rel.source.~class+rel.type.toString()+rel.target.~class;
                 r = r.toLowerCase();
		  	     switch  (rel.type.toString()){
		         case "One2One" : suffix =hash.get("sourceMethodName");%] [%
		         case "One2Many" : %] for ([%=hash.get("target").~fullName%] target : targets[%=hash.get("sourceMethodName")%]) {[%
		         case "Many2Many" : %] for ([%=hash.get("target").~fullName%] target : targets[%=hash.get("sourceMethodName")%]) {[%
		         }         
		                
                 %] 
                  [%=stringPK(hash.get("target"),"key"+hash.get("sourceMethodName"), "target"+suffix,hash.get("target").~fullName)%]
 				  [%=hash.get("target").~fullName%] obj[%=suffix%] = context.get(key[%=hash.get("sourceMethodName")%].toString());
                  if (obj[%=suffix%] == null){
                 
                 obj[%=suffix%] = new [%=serializer%]().load(target[%=suffix%],context,connections);
                 context.put(key[%=hash.get("sourceMethodName")%].toString(),obj[%=suffix%]);
                 }
                 [%=rel.source.~fullName%][%=rel.type.toString()%][%=rel.target.~class%]SerializerRule   [%=r%] = new [%=rel.source.~fullName%][%=rel.type.toString()%][%=rel.target.~class%]SerializerRule();
                 [%=r%].setSource(obj);
                 [%=r%].setTarget(obj[%=suffix%]);
                 connections.put([%=r%] .getKey(),[%=r%] );
                 
                 [%

		  	     switch  (rel.type.toString()){
		         case "One2One" : %] [%
		         case "One2Many" : %] }[%
		         case "Many2Many" : %]}[%
		         }         
		         
		     }    
		     var assosiations = type::Assosiation.allInstances()->select(t|t.target.uid = tp.uid and t.source.uid <> t.target.uid);
		     for (rel in assosiations){
		         if ( rel.findClassifier(util.getHint(model_mapper,"No Assosiation"))){
		                continue;
		         }

                rel.source.mappingType2Java(recipe,ingredient,"VIEW");
                var serializer = rel.source.~fullName+"Serializer";
		         
                rel.source.mappingType2Java(recipe,ingredient,"MODEL");
                rel.target.mappingType2Java(recipe,ingredient,"MODEL");

                var hash = rel.targetSideNamesCalculation();
		         
		         
		  	     switch  (rel.type.toString()){
		         case "One2One" : %]  [%=hash.get("source").~fullName%]    source[%=hash.get("targetMethodName")%] = jpa.get[%=hash.get("targetMethodName")%]();[%
		         case "One2Many" : %] [%=hash.get("source").~fullName%]    source[%=hash.get("targetMethodName")%] = jpa.get[%=hash.get("targetMethodName")%]();[%
		         case "Many2Many" : %] java.util.Collection<[%=hash.get("source").~fullName%]> sources = jpa.get[%=hash.get("targetMethodName")%]();[%
		         }                

                 var suffix=hash.get("targetMethodName");
                 var r = rel.source.~class+rel.type.toString()+rel.target.~class;
                 r = r.toLowerCase();
		  	     switch  (rel.type.toString()){
		         case "One2One" : %] [%
		         case "One2Many" : %] [%
		         case "Many2Many" : suffix ="";%] for ([%=hash.get("source").~fullName%] source : sources[%=hash.get("targetMethodName")%]) {[%
		         }         
		                
                 %] 
                 
                  [%=stringPK(hash.get("source"),"key"+hash.get("targetMethodName"), "source"+suffix,hash.get("source").~fullName)%]
				  [%=hash.get("source").~fullName%] obj[%=suffix%] = context.get(key[%=hash.get("targetMethodName")%].toString());
                  if (obj[%=suffix%] == null){
                 
                 obj[%=suffix%] = new [%=serializer%]().load(source[%=suffix%],context);
                 context.put(key[%=hash.get("targetMethodName")%].toString(),obj[%=suffix%]);
                 }
                 [%=rel.source.~fullName%][%=rel.type.toString()%][%=rel.target.~class%]SerializerRule   [%=r%] = new [%=rel.source.~fullName%][%=rel.type.toString()%][%=rel.target.~class%]SerializerRule();
                 [%=r%].setSource(obj[%=suffix%]);
                 [%=r%].setTarget(obj);
                 connections.put([%=r%].getKey(),[%=r%]);
                 
                 [%

		  	     switch  (rel.type.toString()){
		         case "One2One" : %] [%
		         case "One2Many" : %] [%
		         case "Many2Many" : %]}[%
		         }         
		         
		     }
		
            if (tp.~extension.isDefined()){
               tp = tp.~extension;
            }else{
               break;
            }
         }%]  
         return obj;
       }
      [% tp.mappingType2Java(recipe,ingredient,"VIEW");%]
       public void  save([%=tp.~fullName%] obj){
       [%=PK(type,"pk","obj",fullName,recipe,ingredient)%]

	         if (obj.getOperation() != null ){
		         if ( "R".equals(obj.getOperation()) ){
                      [%=fullName%] jpa = em.em.find([%=fullName%] , pk );
		              remove(obj,jpa);
		              removeWalk(obj);
		              return;
		         }
		         if ( "I".equals(obj.getOperation()) ){
		              insert(obj);
		              insertWalk(obj);
		              return;
		         }
		         if ("U".equals(obj.getOperation()) ){
                 [%=fullName%] jpa = em.em.find([%=fullName%] , pk );
		         [% 
		         while  (1 == 1) {%]
		          [%=serializer(tp,type.~skipAttributes,"obj","jpa")%]
		         [%  
		            if (tp.~extension.isDefined()){
		               tp = tp.~extension;
		            }else{
		               break;
		            }
		         }%]  
		         }
	         }
		    saveWalk(obj);
        }

	         
         [%
         var methods : Sequence = Sequence{"save","insert","remove"};
         for ( call in methods ){
        %]public void [%=call%]Walk([%=tp.~fullName%] obj){[%
 		     var assosiations = type::Assosiation.allInstances()->select(t|t.source.uid = tp.uid);
		     for (rel in assosiations){
		         if ( rel.findClassifier(util.getHint(model_mapper,"No Assosiation"))){
		                continue;
		         }
                rel.target.mappingType2Java(recipe,ingredient,"VIEW");
                rel.source.mappingType2Java(recipe,ingredient,"VIEW");

                var hash = rel.sourceSideNamesCalculation();
		         
		  	     switch  (rel.type.toString()){
		         case "One2One" : %]  [%=hash.get("target").~fullName%]  target[%=hash.get("sourceMethodName")%] =  obj.get[%=hash.get("sourceMethodName")%]();[%
		         case "One2Many" : %] java.util.Collection<[%=hash.get("target").~fullName%]>  targets[%=hash.get("sourceMethodName")%] =   obj.get[%=hash.get("sourceMethodName")%]();[%
		         case "Many2Many" : %] java.util.Collection<[%=hash.get("target").~fullName%]>  targets[%=hash.get("sourceMethodName")%] =   obj.get[%=hash.get("sourceMethodName")%]();[%
		         }                

                 var suffix="";
		  	     switch  (rel.type.toString()){
		         case "One2One" : suffix =hash.get("sourceMethodName");%] [%
		         case "One2Many" : %] for ([%=hash.get("target").~fullName%] target : targets[%=hash.get("sourceMethodName")%]) {[%
		         case "Many2Many" : %] for ([%=hash.get("target").~fullName%] target : targets[%=hash.get("sourceMethodName")%]) {[%
		         }         
		                
                 %] 
                  new [%=hash.get("target").~fullName%]Serializer().[%=call%](target[%=suffix%]);
                 [%

		  	     switch  (rel.type.toString()){
		         case "One2One" : %] [%
		         case "One2Many" : %] }[%
		         case "Many2Many" : %]}[%
		         }         
		         
		     }    
		     
		     var assosiations = type::Assosiation.allInstances()->select(t|t.target.uid = tp.uid and t.source.uid <> t.target.uid);
		     for (rel in assosiations){
		         if ( rel.findClassifier(util.getHint(model_mapper,"No Assosiation"))){
		                continue;
		         }
		         
                rel.source.mappingType2Java(recipe,ingredient,"VIEW");
                rel.target.mappingType2Java(recipe,ingredient,"VIEW");

                var hash = rel.targetSideNamesCalculation();
		         
		         
		  	     switch  (rel.type.toString()){
		         case "One2One" : %]  [%=hash.get("source").~fullName%]    source[%=hash.get("targetMethodName")%] = obj.get[%=hash.get("targetMethodName")%]();[%
		         case "One2Many" : %] [%=hash.get("source").~fullName%]    source[%=hash.get("targetMethodName")%] = obj.get[%=hash.get("targetMethodName")%]();[%
		         case "Many2Many" : %] java.util.Collection<[%=hash.get("source").~fullName%]> sources = obj.get[%=hash.get("targetMethodName")%]();[%
		         }                

                 var suffix=hash.get("targetMethodName");
		  	     switch  (rel.type.toString()){
		         case "One2One" : %] [%
		         case "One2Many" : %] [%
		         case "Many2Many" : suffix ="";%] for ([%=hash.get("source").~fullName%] source : sources[%=hash.get("targetMethodName")%]) {[%
		         }         
		                
                 %] 
                 obj[%=suffix%] = new [%=hash.get("source").~fullName%]Serializer().[%=call%](source[%=suffix%]);
                 [%
		  	     switch  (rel.type.toString()){
		         case "One2One" : %] [%
		         case "One2Many" : %] [%
		         case "Many2Many" : %]}[%
		         }         
		     }
       %]	         
        }
        [%}%]
        public void  insert([%=tp.~fullName%] obj){
          [%=PK(type,"pkInsert","obj",fullName,recipe,ingredient)%]
        
          [%=fullName%] jpa = new [%=fullName%]();
		         [% 
                 var tp = type;
		         while  (1 == 1) {%]
		          [%=serializer(tp,type.~skipAttributes,"obj","jpa")%]
		         [%  
		            if (tp.~extension.isDefined()){
		               tp = tp.~extension;
		            }else{
		               break;
		            }
		         }%]  
		   em.persist(jpa);
		   [%=addRule (type,"Insert",recipe,ingredient)%]
		   
         }
        
        public void  remove([%=tp.~fullName%] obj, [%=fullName%] jpa){
          [%=PK(type,"pkRemove","obj",fullName,recipe,ingredient)%]
        
          [%=addRule (type,"Remove",recipe,ingredient)%]
        
          em.remove(jpa);
        }
        
   }    
   
[%
@template
 operation serializer (type,skipAttributes, inObj, outObj){
        var util = new Native('org.tura.metamodel.commons.Util');
		for ( field in type.attributes){
		     if (skipAttributes.contains(field) ){
		        continue; 
		     }   
        	%][%=outObj%].set[%=util.mergeAndCapitalize(field.name)%](  [%=inObj%].get[%=util.mergeAndCapitalize(field.name)%]()  );
 			[%}
 }


@template
 operation stringPK (type,name,obj,objFullName){
        var util = new Native('org.tura.metamodel.commons.Util');
 %]
 		  StringBuffer [%=name%] = new StringBuffer();
		  [%for ( field in type.~primaryKey){%]
		   [%=name%].append([%=obj%].get[%=util.mergeAndCapitalize(field.name)%]());
		   [%}%]
		   [%=name%].append("[%=objFullName%]");
 [%
}

@template
 operation PK (type,name,obj,objFullName,recipe,ingredient){
       var util = new Native('org.tura.metamodel.commons.Util');
       if (type.~primaryKey.size()>1){%]
        [%=objFullName%]PK [%=name%] = new  [%=objFullName%]PK();
		  [%for ( field in tp.~primaryKey){%]
		   [%=name%].set[%=util.mergeAndCapitalize(field.name)%](obj.get[%=util.mergeAndCapitalize(field.name)%]());
		   [%}
       }else{
          var field = type.~primaryKey.get(0);
          field.typeRef.mappingType2Java(recipe,ingredient);
       %]
        [%=field.typeRef.~fullName%]   [%=name%] =  [%=obj%].get[%=util.mergeAndCapitalize(field.name)%]();
       [%}
}


@template
 operation addRule (type,rule,recipe,ingredient){
         var tp = type;
          while  (1 == 1) {
		     var assosiations = type::Assosiation.allInstances()->select(t|t.source.uid = tp.uid);
		     for (rel in assosiations){

                rel.target.mappingType2Java(recipe,ingredient,"VIEW");
                rel.source.mappingType2Java(recipe,ingredient,"VIEW");

                var hash = rel.sourceSideNamesCalculation();
		         
		  	     switch  (rel.type.toString()){
		         case "One2One" : %]  [%=hash.get("target").~fullName%]  target[%=hash.get("sourceMethodName")%] =  obj.get[%=hash.get("sourceMethodName")%]();[%
		         case "One2Many" : %] java.util.Collection<[%=hash.get("target").~fullName%]>  targets[%=hash.get("sourceMethodName")%] =   obj.get[%=hash.get("sourceMethodName")%]();[%
		         case "Many2Many" : %] java.util.Collection<[%=hash.get("target").~fullName%]>  targets[%=hash.get("sourceMethodName")%] =   obj.get[%=hash.get("sourceMethodName")%]();[%
		         }                

                 var suffix="";
                 var r = rel.source.~class+rel.type.toString()+rel.target.~class;
                 r = r.toLowerCase();
		  	     switch  (rel.type.toString()){
		         case "One2One" : suffix =hash.get("sourceMethodName");%] [%
		         case "One2Many" : %] for ([%=hash.get("target").~fullName%] target : targets[%=hash.get("sourceMethodName")%]) {[%
		         case "Many2Many" : %] for ([%=hash.get("target").~fullName%] target : targets[%=hash.get("sourceMethodName")%]) {[%
		         }         
		                
                 %] 
                 [%=rel.source.~fullName%][%=rel.type.toString()%][%=rel.target.~class%][%=rule%]JpaRule   [%=r%] = new [%=rel.source.~fullName%][%=rel.type.toString()%][%=rel.target.~class%][%=rule%]JpaRule();
                 [%=r%].setSourceKey(pk[%=rule%]);
                 [% rel.target.mappingType2Java(recipe,ingredient,"MODEL");%]
                 [%=PK(rel.target,"pk"+suffix,"obj"+suffix,rel.target.~fullName,recipe,ingredient)%]   
                 [%=r%].setTargetKey(pk[%=suffix%]);
                 connections.put([%=r%].getKey(),[%=r%] );
                 
                 [%

		  	     switch  (rel.type.toString()){
		         case "One2One" : %] [%
		         case "One2Many" : %] }[%
		         case "Many2Many" : %]}[%
		         }         
		         
		     }    
		     var assosiations = type::Assosiation.allInstances()->select(t|t.target.uid = tp.uid and t.source.uid <> t.target.uid);
		     for (rel in assosiations){

                rel.target.mappingType2Java(recipe,ingredient,"VIEW");
                rel.source.mappingType2Java(recipe,ingredient,"VIEW");

                var hash = rel.targetSideNamesCalculation();
		         
		         
		  	     switch  (rel.type.toString()){
		         case "One2One" : %]  [%=hash.get("source").~fullName%]    source[%=hash.get("targetMethodName")%] = jpa.get[%=hash.get("targetMethodName")%]();[%
		         case "One2Many" : %] [%=hash.get("source").~fullName%]    source[%=hash.get("targetMethodName")%] = jpa.get[%=hash.get("targetMethodName")%]();[%
		         case "Many2Many" : %] java.util.Collection<[%=hash.get("source").~fullName%]> sources = jpa.get[%=hash.get("targetMethodName")%]();[%
		         }                

                 var suffix=hash.get("targetMethodName");
                 var r = rel.source.~class+rel.type.toString()+rel.target.~class;
                 r = r.toLowerCase();
		  	     switch  (rel.type.toString()){
		         case "One2One" : %] [%
		         case "One2Many" : %] [%
		         case "Many2Many" : suffix ="";%] for ([%=hash.get("source").~fullName%] source : sources[%=hash.get("targetMethodName")%]) {[%
		         }         
		                
                 %] 

                 [%=rel.source.~fullName%][%=rel.type.toString()%][%=rel.target.~class%][%=rule%]JpaRule   [%=r%] = new [%=rel.source.~fullName%][%=rel.type.toString()%][%=rel.target.~class%]JpaRule();
                 [%=r%].setSourceKey(pk[%=suffix%]);
                 [% rel.target.mappingType2Java(recipe,ingredient,"MODEL");%]
                 [%=PK(rel.target,"pk"+suffix,"obj"+suffix,rel.target.~fullName,recipe,ingredient)%]   
                 [%=r%].setTargetKey(pk[%=rule%]);
                 connections.put([%=r%].getKey(),[%=r%] );
                 [%

		  	     switch  (rel.type.toString()){
		         case "One2One" : %] [%
		         case "One2Many" : %] [%
		         case "Many2Many" : %]}[%
		         }         
		         
		     }
		
            if (tp.~extension.isDefined()){
               tp = tp.~extension;
            }else{
               break;
            }
         }
}

%]