[%
 import "platform:/plugin/org.tura.metamodel.generation/template/commons/typeElementUtil.eol";
 import "platform:/plugin/org.tura.metamodel.generation/template/commons/categorizedUtil.eol";
 var util = new Native('org.tura.metamodel.commons.Util');
%]
package [%=type.~package%];  


@javax.persistence.Entity(name = "[%=type.~class%]")
@javax.persistence.Table(name = "[%=type.~class.toUpperCase()%]")
public class [%=type.~class%]  [%if (type.~extension.isDefined()){%]  extends [%=type.~extension.~fullName%]  [%}%] {


[%for ( field in type.attributes){
     if (type.~skipAttributes.contains(field) )
        continue; 
     
    field.typeRef.mappingType2Java(recipe,ingredient);

    if (field.findClassifier("ORMEntity",  "entityObject","Bean validation"))%]
    [%=field.~hintDetails%]  
    
    [%if (field.findClassifier("ORMEntity",  "entityObject","Sequence"))%]
    [%=field.~hintDetails%]  
    [%if ( field.pk) %]
    @javax.persistence.Id
    [%if (field.typeRef.~fullName == "java.util.Date"  or field.typeRef.~fullName == "java.sql.Timestamp")%]
	@javax.persistence.Temporal(javax.persistence.TemporalType.TIMESTAMP)
	@javax.persistence.Column(name = "[%=util.mergeAndCapitalize(field.name).toUpperCase()%]")
	private [%= field.typeRef.~fullName%]  [%=util.mergeAndUnCapitalize(field.name)%];
	
	public void set[%=util.mergeAndCapitalize(field.name)%](  [%= field.typeRef.~fullName%]  [%=util.mergeAndUnCapitalize(field.name)%]){
		this.[%=util.mergeAndUnCapitalize(field.name)%] = [%=util.mergeAndUnCapitalize(field.name)%];
	}
	public [%= field.typeRef.~fullName%] get[%=util.mergeAndCapitalize(field.name)%](){
		return [%=util.mergeAndUnCapitalize(field.name)%];
	}
	
[%}%]

	[%
	  var assosiations = type::Assosiation.allInstances()->select(t|t.source.uid = type.uid);
      for (rel in assosiations){
        var target = rel.target;
	    if (target.isKindOf(domain::TypeReference )){
	         target = target.typeRef;
	    }
         var sourceMethodName = util.mergeAndCapitalize(target.name);

         if (rel.sourceOperation.isDefined())
             sourceMethodName = util.mergeAndCapitalize(rel.sourceOperation);
         var sourceProperty =  util.mergeAndUnCapitalize(sourceMethodName);
      
        var source = rel.source;
	    if (source.isKindOf(domain::TypeReference )){
	         source = source.typeRef;
	    }
        var targetMethodName = util.mergeAndCapitalize(source.name);

         if (rel.targetOperation.isDefined())
             sourceMethodName = util.mergeAndCapitalize(rel.targetOperation);
         var targetProperty =  util.mergeAndUnCapitalize(targetMethodName);
      
      
  	     switch  (rel.type.toString()){
         case "One2One" : %] @javax.persistence.OneToOne(mappedBy="[%=targetProperty%]")[%
         case "One2Many" : %] @javax.persistence.OneToMany(mappedBy="[%=targetProperty%]")[%
         case "Many2Many" : %] @javax.persistence.ManyToMany(mappedBy="[%=targetProperty%]")[%
         }
      
  	     switch  (rel.type.toString()){
         case "One2One" : %] private [%=target.~fullName%]  [%=sourceProperty%];[%
         case "One2Many" : %]  private java.util.Collection<[%=target.~fullName%]>  [%=sourceProperty%];[%
         case "Many2Many" : %] private java.util.Collection<[%=target.~fullName%]>  [%=sourceProperty%];[%
         }
      
  	     switch  (rel.type.toString()){
         case "One2One" : %] public [%=target.~fullName%]  get[%=sourceMethodName%]()[%
         case "One2Many" : %] public java.util.Collection<[%=target.~fullName%]>  get[%=sourceMethodName%]()[%
         case "Many2Many" : %] public java.util.Collection<[%=target.~fullName%]>  get[%=sourceMethodName%]()[%
         }                
         %] { return [%=sourceProperty%]; } [%
         
  	     switch  (rel.type.toString()){
         case "One2One" : %] public  void set[%=sourceMethodName%]([%=target.~fullName%]  [%=sourceProperty%])[%
         case "One2Many" : %] public  void  set[%=sourceMethodName%](java.util.Collection<[%=target.~fullName%]> [%=sourceProperty%])[%
         case "Many2Many" : %] public  void  set[%=sourceMethodName%](java.util.Collection<[%=target.~fullName%]> [%=sourceProperty%])[%
         }                
         %] { this.[%=sourceProperty%]=[%=sourceProperty%]; } [%
         
         
      }
	%]

	[%
	  var assosiations = type::Assosiation.allInstances()->select(t|t.target.uid = type.uid);
      for (rel in assosiations){
        var source = rel.source;
	    if (source.isKindOf(domain::TypeReference )){
	         source = source.typeRef;
	    }
      
         var targetMethodName = util.mergeAndCapitalize(source.name);
         if (rel.targetOperation.isDefined())
             sourceMethodName = util.mergeAndCapitalize(rel.targetOperation);
         var targetProperty =  util.mergeAndUnCapitalize(targetMethodName);
      
         var target = rel.target;
	     if (target.isKindOf(domain::TypeReference )){
	         target = target.typeRef;
	     }
      
         var sourceMethodName = util.mergeAndCapitalize(target.name);
         if (rel.sourceOperation.isDefined())
             sourceMethodName = util.mergeAndCapitalize(rel.sourceOperation);
         var sourceProperty =  util.mergeAndUnCapitalize(sourceMethodName);
      
  	     switch  (rel.type.toString()){
         case "One2One" : %] [%=rel.joinColumns()%] @javax.persistence.OneToOne[%
         case "One2Many" : %]  [%=rel.joinColumns()%] @javax.persistence.ManyToOne[%
         case "Many2Many" : %] [%=rel.joinTable(sourceMethodName,targetMethodName)%] @javax.persistence.ManyToMany[%
         }
      
      
  	     switch  (rel.type.toString()){
         case "One2One" : %] private [%=source.~fullName%]  [%=targetProperty%];[%
         case "One2Many" : %] private [%=source.~fullName%]  [%=targetProperty%];[%
         case "Many2Many" : %] private java.util.Collection<[%=source.~fullName%]>  [%=targetProperty%];[%
         }
      
  	     switch  (rel.type.toString()){
         case "One2One" : %] public [%=source.~fullName%]  get[%=targetMethodName%]()[%
         case "One2Many" : %] public [%=source.~fullName%]  get[%=targetMethodName%]()[%
         case "Many2Many" : %] public java.util.Collection<[%=source.~fullName%]>  get[%=targetMethodName%]()[%
         }                
         %] { return [%=targetProperty%]; } [%

  	     switch  (rel.type.toString()){
         case "One2One" : %] public  void  set[%=targetMethodName%]([%=source.~fullName%] [%=targetProperty%])[%
         case "One2Many" : %] public void set[%=targetMethodName%]([%=source.~fullName%] [%=targetProperty%])[%
         case "Many2Many" : %] public  void set[%=targetMethodName%](java.util.Collection<[%=source.~fullName%]> [%=targetProperty%])[%
         }                
         %] { this.[%=targetProperty%]=[%=targetProperty%]; } [%


      }
	%]
}
[%
@template
operation type::Assosiation  joinColumns(){
	  var i = 0;
      %]@javax.persistence.JoinColumns({[%
            for (lnk in self.links){
            if (i <> 0){%],[%}%]@javax.persistence.JoinColumn(name="[%=lnk.detailField.name%]")[%  
            }
    %]}) 
[%
}
@template
operation type::Assosiation  joinTable(src,target){
	  var i = 0;
	  var table = "RL_"+src.toUpperCase()+"_"+target.toUpperCase();
      if (self.source.findClassifier("ORMEntity",  "entityObject","Many2ManyTable"))
         table = self.source.~hintDetails;
      %]@javax.persistence.JoinTable(name="[%=table%]",  
              joinColumns={[%
	            for (lnk in self.links){
	            if (i <> 0){%],[%}%]@javax.persistence.JoinColumn(name="[%=src.toLowerCase()%]_[%=lnk.masterField.name%]")[%  
	            }
              %]},  
              inverseJoinColumns={[%
	            for (lnk in self.links){
	            if (i <> 0){%],[%}%]@javax.persistence.JoinColumn(name="[%=target.toLowerCase()%]_[%=lnk.detailField.name%]")[%  
	            }
              %]})      
[%
}%]