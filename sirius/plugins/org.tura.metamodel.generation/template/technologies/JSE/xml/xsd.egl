<#assign percent = "%" >
<#assign start = "[" >
<#assign end = "]" >
${start}${percent} 
import "platform:/plugin/org.tura.metamodel.generation/template/commons/typeElementUtil.eol";
import "platform:/plugin/org.tura.metamodel.generation/template/commons/categorizedUtil.eol";

 ${percent}${end}
 [%
      var util = new Native('org.tura.metamodel.commons.Util');
      for(type in typeCollection.values()){
         %]<xs:complexType name="[%=type.~class%]">
          [%
           if (type.~extension.isDefined()){ 
           type.~extension.mappingType2XML(recipe,ingredient);
           %] <xs:complexContent>
           <xs:extension base="[%=getNamespace(type.~extension.~namespace,targetnamespace,fullHash,returnHash )%][%=type.~extension.~class%]">  
            [%}
          %]<xs:sequence>
          [%
          
		for ( field in type.attributes){
		     if (type.~skipAttributes.contains(field) ){
		        continue; 
		     }   
        		
		    field.typeRef.mappingType2XML(recipe,ingredient);
		    %] <xs:element name="[%=util.mergeAndUnCapitalize(field.name)%]"  type=  "[%=getNamespace(field.typeRef.~namespace,targetnamespace,fullHash,returnHash)%][%=field.typeRef.~class%]"/>
		    [%
		
			}
			
		  var assosiations = type::Assosiation.allInstances()->select(t|t.source.uid = type.uid);
	      for (rel in assosiations){
	         if ( rel.findClassifier(util.getHint(model_mapper,"No Assosiation"))){
	                continue;
	         }
	        var target = rel.target;
		    if (target.isKindOf(type::TypeReference )){
		         target = target.typeRef;
		    }
	         var sourceMethodName = util.mergeAndCapitalize(target.name);
	
	         if (rel.sourceOperation.isDefined())
	             sourceMethodName = util.mergeAndCapitalize(rel.sourceOperation);
	         var sourceProperty =  util.mergeAndUnCapitalize(sourceMethodName);
	      
	        var source = rel.source;
		    if (source.isKindOf(type::TypeReference )){
		         source = source.typeRef;
		    }
	        var targetMethodName = util.mergeAndCapitalize(source.name);
	
	         if (rel.targetOperation.isDefined())
	             sourceMethodName = util.mergeAndCapitalize(rel.targetOperation);
	         var targetProperty =  util.mergeAndUnCapitalize(targetMethodName);
	      
	  	     switch  (rel.type.toString()){
	         case "One2One" : %]    <xs:element name="[%=sourceProperty%]"  type=  "[%=getNamespace(target.~namespace,targetnamespace,fullHash,returnHash)%][%=target.~class%]"/>[%
	         case "One2Many" : %]  <xs:element name="[%=sourceProperty%]"  type=  "[%=getNamespace(target.~namespace,targetnamespace,fullHash,returnHash)%][%=target.~class%]"   maxOccurs="unbounded"/> [%
	         case "Many2Many" : %]  <xs:element name="[%=sourceProperty%]"  type=  "[%=getNamespace(target.~namespace,targetnamespace,fullHash,returnHash)%][%=target.~class%]"   maxOccurs="unbounded"/> [%
	         }
	      }

	  var assosiations = type::Assosiation.allInstances()->select(t|t.target.uid = type.uid);
      for (rel in assosiations){
	    if ( rel.findClassifier(util.getHint(model_mapper,"No Assosiation"))){
	          continue;
	    }

        var source = rel.source;
	    if (source.isKindOf(type::TypeReference )){
	         source = source.typeRef;
	    }
      
      var suffix ="";
       if (rel.source.uid = rel.target.uid){
          suffix = "Master";
       }
      
         var targetMethodName = util.mergeAndCapitalize(source.name+suffix);
         if (rel.targetOperation.isDefined())
             sourceMethodName = util.mergeAndCapitalize(rel.targetOperation);
         var targetProperty =  util.mergeAndUnCapitalize(targetMethodName);
      
         var target = rel.target;
	     if (target.isKindOf(type::TypeReference )){
	         target = target.typeRef;
	     }
      
         var sourceMethodName = util.mergeAndCapitalize(target.name);
         if (rel.sourceOperation.isDefined())
             sourceMethodName = util.mergeAndCapitalize(rel.sourceOperation);
         var sourceProperty =  util.mergeAndUnCapitalize(sourceMethodName);
      
  	     switch  (rel.type.toString()){
         case "One2One" : %]     <xs:element name="[%=targetProperty%]" type="[%=getNamespace(source.~namespace,targetnamespace,fullHash,returnHash)%][%=source.~class%]" />[%
         case "One2Many" : %]   <xs:element name="[%=targetProperty%]" type="[%=getNamespace(source.~namespace,targetnamespace,fullHash,returnHash)%][%=source.~class%]" />[%
         case "Many2Many" : %] <xs:element name="[%=targetProperty%]" type="[%=getNamespace(source.~namespace,targetnamespace,fullHash,returnHash)%][%=source.~class%]"  maxOccurs="unbounded"/>[%
         }                

      }
	      %]
	      </xs:sequence>
	      [%
	       if (type.~extension.isDefined()){ %]</xs:extension>  
	       </xs:complexContent>
	        [%}
	        
	     %]</xs:complexType>
	      [%

      }

operation getNamespace(namespace,targetNamespace,fullHash,returnHash){
  if ("http://www.w3.org/2001/XMLSchema".equals(namespace)){
     return "xs:";
  }
  if(namespace.equals(targetNamespace)){
      return "";
  }else{
      returnHash.put("ns"+fullHash.get(namespace).get(1),namespace);
      return "ns"+fullHash.get(namespace).get(1)+":";
  } 
}
%]