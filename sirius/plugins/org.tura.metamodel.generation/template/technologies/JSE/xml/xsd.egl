<#assign percent = "%" >
<#assign start = "[" >
<#assign end = "]" >
${start}${percent} 
import "platform:/plugin/org.tura.metamodel.generation/template/commons/typeElementUtil.eol";
import "platform:/plugin/org.tura.metamodel.generation/template/commons/categorizedUtil.eol";
import "platform:/plugin/org.tura.metamodel.generation/template/commons/assosiation.eol";

 ${percent}${end}
 [%
      var util = new Native('org.tura.metamodel.commons.Util');
      for(type in typeCollection.values()){
         %]<xs:complexType name="[%=type.~class%]">
          [%
           if (type.~extension.isDefined()){ 
           type.~extension.mappingType2XML(recipe,ingredient);
           %] <xs:complexContent>
           <xs:extension base="[%=getNamespace(type.~extension.~namespace,targetnamespace,fullHash,returnHash )%][%=type.~extension.~class%]">  
            [%}
          %]<xs:sequence>
          [%
           if (not type.~extension.isDefined()){ 
           %] 
               <xs:element name="operation" type="xs:string"/>
            [%}
          
          
		for ( field in type.attributes){
		     if (type.~skipAttributes.contains(field) ){
		        continue; 
		     }   
        		
		    field.typeRef.mappingType2XML(recipe,ingredient);
		    %] <xs:element name="[%=util.mergeAndUnCapitalize(field.name)%]"  type=  "[%=getNamespace(field.typeRef.~namespace,targetnamespace,fullHash,returnHash)%][%=field.typeRef.~class%]"/>
		    [%
		
			}
			
		  var assosiations = type::Assosiation.allInstances()->select(t|t.source.uid = type.uid);
	      for (rel in assosiations){
	         if ( rel.findClassifier(util.getHint(model_mapper,"No Assosiation"))){
	                continue;
	         }
	         
            var hash = rel.sourceSideNamesCalculation();
	      
	  	     switch  (rel.type.toString()){
	         case "One2One" : %]    <xs:element name="[%=hash.get("sourceProperty")%]"  type=  "[%=getNamespace(hash.get("target").~namespace,targetnamespace,fullHash,returnHash)%][%=hash.get("target").~class%]"/>[%
	         case "One2Many" : %]  <xs:element name="[%=hash.get("sourceProperty")%]"  type=  "[%=getNamespace(hash.get("target").~namespace,targetnamespace,fullHash,returnHash)%][%=hash.get("target").~class%]"   maxOccurs="unbounded"/> [%
	         case "Many2Many" : %]  <xs:element name="[%=hash.get("sourceProperty")%]"  type=  "[%=getNamespace(hash.get("target").~namespace,targetnamespace,fullHash,returnHash)%][%=hash.get("target").~class%]"   maxOccurs="unbounded"/> [%
	         }
	      }

	  var assosiations = type::Assosiation.allInstances()->select(t|t.target.uid = type.uid);
      for (rel in assosiations){
	    if ( rel.findClassifier(util.getHint(model_mapper,"No Assosiation"))){
	          continue;
	    }

         var hash = rel.targetSideNamesCalculation();
      
  	     switch  (rel.type.toString()){
         case "One2One" : %]     <xs:element name="[%=hash.get("targetProperty")%]" type="[%=getNamespace(hash.get("source").~namespace,targetnamespace,fullHash,returnHash)%][%=hash.get("source").~class%]" />[%
         case "One2Many" : %]   <xs:element name="[%=hash.get("targetProperty")%]" type="[%=getNamespace(hash.get("source").~namespace,targetnamespace,fullHash,returnHash)%][%=hash.get("source").~class%]" />[%
         case "Many2Many" : %] <xs:element name="[%=hash.get("targetProperty")%]" type="[%=getNamespace(hash.get("source").~namespace,targetnamespace,fullHash,returnHash)%][%=hash.get("source").~class%]"  maxOccurs="unbounded"/>[%
         }                

      }
	      %]
	      </xs:sequence>
	      [%
	       if (type.~extension.isDefined()){ %]</xs:extension>  
	       </xs:complexContent>
	        [%}
	        
	     %]</xs:complexType>
	      [%

 		var assosiations = type::Assosiation.allInstances()->select(t|t.source.uid = type.uid);
 		for ( rel in assosiations  ){
	       if ( not rel.findClassifier(util.getHint(model_mapper,"No Assosiation"))){
	              continue;
	       }

	       if ( rel.type.toString()<>"Many2Many"   ){
	              continue;
           }
           var hash = rel.sourceSideNamesCalculation();
           
          %]<xs:complexType name="[%=rel.source.~class%]Many2Many[%=rel.target.~class%]Relation">
          <xs:sequence>
          <xs:element name="operation" type="xs:string"/>
          [%
               for (lnk in rel.links){
                  lnk.masterField.typeRef.mappingType2XML(recipe,ingredient);
                  var master = util.mergeAndUnCapitalize(lnk.masterField.name);
		          lnk.detailField.typeRef.mappingType2XML(recipe,ingredient);
		          var detail = util.mergeAndUnCapitalize(lnk.detailField.name);
                  %]
                  <xs:element name="[%=hash.get("targetMethodName").toLowerCase()%]_[%=master%]"   type="[%=getNamespace(lnk.masterField.typeRef.~namespace,targetnamespace,fullHash,returnHash)%][%=lnk.masterField.typeRef.~class%]"/> 
                  <xs:element name="[%=hash.get("sourceMethodName").toLowerCase()%]_[%=detail%]"   type="[%=getNamespace(lnk.detailField.typeRef.~namespace,targetnamespace,fullHash,returnHash)%][%=lnk.detailField.typeRef.~class%]"/> 
                  [%
                  
              }
  	       %]
  	       </xs:sequence>
  	       </xs:complexType>[%
           
       }
      }

operation getNamespace(namespace,targetNamespace,fullHash,returnHash){
  if ("http://www.w3.org/2001/XMLSchema".equals(namespace)){
     return "xs:";
  }
  if(namespace.equals(targetNamespace)){
      return "";
  }else{
      returnHash.put("ns"+fullHash.get(namespace).get(1),namespace);
      return "ns"+fullHash.get(namespace).get(1)+":";
  } 
}
%]