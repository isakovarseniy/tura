/*
 *   Tura - Application generation solution
 *
 *   Copyright (C) 2008-2023 2182342 Ontario Inc ( arseniy.isakov@turasolutions.com ).
 *
 *
 *   This project includes software developed by Arseniy Isakov
 *   https://github.com/isakovarseniy/tura
 *   All rights reserved. This program and the accompanying materials
 *   are made available under the terms of the Eclipse Public License v2.0
 *   which accompanies this distribution, and is available at
 *   http://www.eclipse.org/legal/epl-v20.html
 */

operation contains(primaryKey, field){
        for( pf in primaryKey){
            if (pf.name.equals(field.name) ){
                return true;
            }
        }
    return false;    
}

 operation type::TypeElement collectType(pk,model_mapper){
    var tp = self;
    var primaryKey=pk;
    if (pk == null){
        primaryKey=new Native('java.util.ArrayList');
        self.~primaryKey = primaryKey;
    }

     for(field in tp.attributes){
        if (field.pk  and not contains(primaryKey, field)){
            primaryKey.add(field);
        }
     }
    var pkg  =  tp.eContainer();
//    var extension = type::Generalization.allInstances()->select(t|t.source.uid = tp.uid  and not t.isImplements(model_mapper) ).first();
    var extension = pkg.relationships->select(t|t.isTypeOf(type::Generalization) and t.source.uid = tp.uid  and not t.isImplements(model_mapper) ).first();
    if (extension <> null){
	   var ex =  extension.target;
	   if (ex.isKindOf(type::TypeReference )){
	       ex = extension.target.typeRef;
	   }
	   ex.collectType(primaryKey, model_mapper);
    }
}


 operation type::Assosiation findTypeOfAssosiation(model_mapper){
     var util = new Native('org.tura.metamodel.commons.Util');
     var masterType;
     var detailType;
     var property;
     var containment=false; 
     
     
     if( self.type.toString() =="One2Many"  ){
        masterType = self.source;
	    if (masterType.isKindOf(type::TypeReference )){
	         masterType = masterType.typeRef;
	    }
        detailType = self.target;
	    if (detailType.isKindOf(type::TypeReference )){
	         detailType = detailType.typeRef;
	    }

         property = util.mergeAndCapitalize(detailType.name);
         if (self.containment.toString() == "Source"){
           containment=true;
         }
     }
     if( self.type.toString() == "One2One" and (self.containment.toString()=="Source" or self.containment.toString()=="Non") ){
         masterType = self.source;
	    if (masterType.isKindOf(type::TypeReference )){
	         masterType = masterType.typeRef;
	    }
         
        detailType = self.target;
	    if (detailType.isKindOf(type::TypeReference )){
	         detailType = detailType.typeRef;
	    }
         
         property = util.mergeAndCapitalize(detailType.name);
         if (self.containment.toString() == "Source"){
           containment=true;
         }
     }
     if( self.type.toString() == "One2One" and self.containment.toString()=="Target"  ){
         masterType = self.target;
         detailType = self.source;
         property = util.mergeAndCapitalize(detailType.name);
         if (self.containment.toString() == "Target"){
           containment=true;
         }
         
     }

     if( self.type.toString() == "Many2Many"  ){
         masterType = self.source;
         detailType = self.target;
         property = util.mergeAndCapitalize(detailType.name);
     }
	     
     var hash = new Native('java.util.HashMap');
     hash.put("masterType",masterType);
     hash.put("detailType",detailType);
     hash.put("property",property);
     hash.put("containment",containment);

      return hash;
 }


 operation type::TypeElement collectType(typeCollection,model_mapper,skattr,pk,bndattr){
    var tp = self.unwrap();

    var util = new Native('org.tura.metamodel.commons.Util');

    if (not typeCollection.contains(tp)){
        typeCollection.add(tp);
    }
    
    
    var skipAttributes=new Native('java.util.ArrayList');
    var ignoredAttribute=new Native('java.util.ArrayList');
    
    var primaryKey=pk;
    if (pk == null){
        primaryKey=new Native('java.util.ArrayList');
        tp.~primaryKey = primaryKey;
    }

     if ( not tp.isPersistentInterface(model_mapper)){
	     for(field in tp.attributes){
	        if (field.pk and not contains(primaryKey, field)  ){
	            primaryKey.add(field);
	        }
	     }
     }

     var pkg = tp.eContainer();
//     var assosiations = type::Assosiation.allInstances()->select(t|t.source.uid = tp.uid  and t.source.uid <> t.target.uid);
     var assosiations = pkg.relationships->select(t|t.isTypeOf(type::Assosiation) and t.source.uid = tp.uid  and t.source.uid <> t.target.uid);
     for (rel in assosiations){
        rel.check(); 
  	    var tp1 =  rel.target.unwrap();
	    if (not typeCollection.contains(tp1)){
	        tp1.collectType(typeCollection,model_mapper,null,null,null);
	    }
     }


//     var assosiations = type::Assosiation.allInstances()->select(t|t.target.uid = tp.uid  and t.source.uid <> t.target.uid);
     var assosiations = pkg.relationships->select(t|t.isTypeOf(type::Assosiation) and t.target.uid = tp.uid  and t.source.uid <> t.target.uid);
     for (rel in assosiations){
        rel.check(); 
  	    var tp1 =  rel.source.unwrap();
	    if (not typeCollection.contains(tp1)){
	    	tp1.collectType(typeCollection,model_mapper,null,null,null);
	    }
     }

//     var assosiations = type::Assosiation.allInstances()->select(t|t.target.uid = tp.uid and (t.type.toString() = "One2One" or t.type.toString() = "One2Many"));
     var assosiations = pkg.relationships->select(t|t.isTypeOf(type::Assosiation) and t.target.uid = tp.uid and (t.type.toString() = "One2One" or t.type.toString() = "One2Many"));
     for (rel in assosiations){
         for (lnk in rel.links){
             skipAttributes.add(lnk.detailField);
         }
     }           
        
//    var extension = type::Generalization.allInstances()->select(t|t.source.uid = tp.uid  and not t.isImplements(model_mapper) ).first();
    var extension = pkg.relationships->select(t|t.isTypeOf(type::Generalization) and t.source.uid = tp.uid  and not t.isImplements(model_mapper) ).first();
    if (extension <> null){
	   var ex =  extension.target.unwrap();
	   ex.collectType(typeCollection,model_mapper,skipAttributes,primaryKey,ignoredAttribute);
	   tp.~extension = ex;
    }
    
//    var interfaces = type::Generalization.allInstances()->select(t|t.source.uid = tp.uid  and t.isImplements(model_mapper) );
    var interfaces = pkg.relationships->select(t|t.isTypeOf(type::Generalization) and t.source.uid = tp.uid  and t.isImplements(model_mapper) );
     for (interface in interfaces){
	   var ex =  interface.target.unwrap();
	   ex.collectType(typeCollection,model_mapper,skipAttributes,primaryKey,ignoredAttribute);
    }    

    tp.~skipAttributes=skipAttributes;
    tp.~ignoredAttribute=ignoredAttribute;
    

 }
 

operation type::Assosiation  check(){
        if (self.type.toString() == "Many2Many" ){
	        for (link in self.links){
	             if (not link.masterField.pk and not link.masterField.uk){
	                throw "Assosiation between type "+ self.source.name + " and "+self.target.name+" has wrong assosiation. Master field has to be primary key ";
	             }
	             if (not link.detailField.pk){
	                throw "Assosiation between type "+ self.source.name + " and "+self.target.name+" has wrong assosiation. Detail field  has to be primary key   ";
	             }
	        }  
        }else{
	        for (link in self.links){
	             if (not link.masterField.pk  and not link.masterField.uk){
	                throw "Assosiation between type "+ self.source.name + " and "+self.target.name+" has wrong assosiation. Master field has to be primary key ";
	             }
	             if (link.detailField.pk){
	                throw "Assosiation between type "+ self.source.name + " and "+self.target.name+" has wrong assosiation. Detail field should not be primary key  ";
	             }
	        }  
        }
}

operation type::Assosiation  sourceSideNamesCalculation(){
   var util = new Native('org.tura.metamodel.commons.Util');

    var target = self.target;
    if (target.isKindOf(type::TypeReference )){
         target = target.typeRef;
    }
    
   var suffix ="";
   if (self.source.uid = self.target.uid){
      suffix = "Master";
   }
    var containment = false;
    if (self.containment.toString() == "Source"){
           containment=true;
    }
    if (self.internal){
           containment=true;
    }
    
    
     var sourceMethodName = util.mergeAndCapitalize(target.name);

     if (self.sourceOperation.isDefined()){
         sourceMethodName = util.mergeAndCapitalize(self.sourceOperation);
      }
     var sourceProperty =  util.mergeAndUnCapitalize(sourceMethodName);
  
    var source = self.source;
    if (source.isKindOf(type::TypeReference )){
         source = source.typeRef;
    }
    var targetMethodName = util.mergeAndCapitalize(source.name+suffix);

     if (self.targetOperation.isDefined()){
         targetMethodName = util.mergeAndCapitalize(self.targetOperation);
     }
     var targetProperty =  util.mergeAndUnCapitalize(targetMethodName);

     var hash = new Native('java.util.HashMap');
     hash.put("sourceMethodName",sourceMethodName);
     hash.put("sourceProperty",sourceProperty);
     hash.put("targetMethodName",targetMethodName);
     hash.put("targetProperty",targetProperty);
     hash.put("target",target);
     hash.put("source",source);
     hash.put("containment",containment);

      return hash;
}

operation type::Assosiation  targetSideNamesCalculation(){
   var util = new Native('org.tura.metamodel.commons.Util');

    var source = self.source;
    if (source.isKindOf(type::TypeReference )){
         source = source.typeRef;
    }
  
   var suffix ="";
   if (self.source.uid = self.target.uid){
      suffix = "Master";
   }
  
    var containment = false;
    if (self.containment.toString() == "Target"){
           containment=true;
    }
    if (self.internal){
           containment=false;
    }
  
  
     var targetMethodName = util.mergeAndCapitalize(source.name+suffix);
     if (self.targetOperation.isDefined()){
         targetMethodName = util.mergeAndCapitalize(self.targetOperation);
      }
     var targetProperty =  util.mergeAndUnCapitalize(targetMethodName);
  
     var target = self.target;
     if (target.isKindOf(type::TypeReference )){
         target = target.typeRef;
     }
  
     var sourceMethodName = util.mergeAndCapitalize(target.name);
     if (self.sourceOperation.isDefined()){
         sourceMethodName = util.mergeAndCapitalize(self.sourceOperation);
      }
     var sourceProperty =  util.mergeAndUnCapitalize(sourceMethodName);

     var hash = new Native('java.util.HashMap');
     hash.put("sourceMethodName",sourceMethodName);
     hash.put("sourceProperty",sourceProperty);
     hash.put("targetMethodName",targetMethodName);
     hash.put("targetProperty",targetProperty);
     hash.put("source",source);
     hash.put("target",target);
     hash.put("containment",containment);

      return hash;

}

operation type::Assosiation targetFn(){
    var target = self.target;
     if (target.isKindOf(type::TypeReference )){
         target = target.typeRef;
     }
    return target;
}

operation type::Assosiation sourceFn(){
    var source = self.source;
     if (source.isKindOf(type::TypeReference )){
         source = source.typeRef;
     }
    return source;
}



operation type::Assosiation merge(hash){
    var source = self.source;
    var isRef = false;
    
    var assosiations  = null;
    if (source.isTypeOf(type::TypeReference )){
         source = source.typeRef;
         isRef = true;
         var pkg = source.eContainer();
//		 assosiations = type::Assosiation.allInstances()->select(t|t.source.uid = source.uid);
		 assosiations = pkg.relationships->select(t|t.isTypeOf(type::Assosiation) and t.source.uid = source.uid);
    }
    var target = self.target;
     if (target.isTypeOf(type::TypeReference )){
         target = target.typeRef;
         isRef = true;
         var pkg = target.eContainer();
//	     assosiations = type::Assosiation.allInstances()->select(t|t.target.uid = target.uid);
	     assosiations = pkg.relationships->select(t|t.isTypeOf(type::Assosiation) and t.target.uid = target.uid);
     }
     if (isRef){
        var obj = null;
        var  mergedAssosiations = null;
        for (rel in assosiations){
            var result = false;
            for ( lnk in rel.links){
            
              var slink = null;  
              slink = self.links->select(t| t.masterField.uid  =  lnk.masterField.uid and  t.detailField.uid = lnk.detailField.uid ).first();
              if  (slink <> null ){
                  result =  true;
              }else{
                  result =  false;
              }
            }
            if (result){
              mergedAssosiations =  rel;
              break;
            }
        }
        if (mergedAssosiations  <> null){
	        var  r1 = mergedAssosiations.uid.hashCode();
	        var  r2  = self.uid.hashCode();
	        
	        if (r1 > r2){
	            obj  = mergedAssosiations.uid;
	        }else{
	            obj  = self.uid;
	        }
        }else{
           throw "Relation not found";
        }
	    return obj;
     }else{
        return null;
     }
}

operation type::Assosiation internalType(){
      if (self.isInternal()){
         return "Internal";
      }
      return "";
}

operation type::Assosiation accessorType(lazy){
      if (lazy){
         return "Lazy";
      }
      return "Eager";
}


operation type::Assosiation accessorType(){
      if (self.isLazy()){
         return "Lazy";
      }
      return "Eager";
}

operation type::Assosiation isLazy(){
     if ( self.lazy and not self.internal ){
        return true;
     }else{
        return false;
     }
}

operation type::Assosiation isInternal(){
     if ( self.internal ){
        return true;
     }else{
        return false;
     }
}



operation type::Generalization isImplements(model_mapper){
    var util = new Native('org.tura.metamodel.commons.Util');
    var type = self.target.unwrap();
    if (type.findClassifier( util.getHint(model_mapper,"Domain Interface"))){
       return true;
    }else{
       return false;
    }
    
}

operation type::TypeElement isPersistentInterface(model_mapper){
    var util = new Native('org.tura.metamodel.commons.Util');
    var type = self.unwrap();
    if (type.findClassifier( util.getHint(model_mapper,"Domain Interface"))  and   type.findClassifier( util.getHint(model_mapper,"Entity Object"))){
       return true;
    }else{
       return false;
    }
    
}

operation  type::Type isTopObject(){
    var pkg = self.eContainer();
//    var assosiations = type::Assosiation.allInstances()->select(t|t.target.uid = self.uid);
    var assosiations = pkg.relationships->select(t|t.isTypeOf(type::Assosiation) and t.target.uid = self.uid);
	for (rel in assosiations){
	   var hash = rel.findTypeOfAssosiation(model_mapper);
	   var masterType =   hash.get("masterType");
	   var detailType = hash.get("detailType");
	   var property =  hash.get("property");
       var containment = hash.get("containment");
     
        if (detailType.uid == self.uid  and   rel.type.toString() <> "Many2Many"  and containment){
           return false;
        }
    }
//    var interfaces = type::Generalization.allInstances()->select(t|t.source.uid = self.uid);
    var interfaces = pkg.relationships->select(t|t.isTypeOf(type::Generalization) and  t.source.uid = self.uid);
        for (interface in interfaces){
           var tp = interface.target.unwrap();
           var isT = tp.isTopObject();
           if ( not isT  ){
                 return  false;
           }
      }
      return  true;
}

