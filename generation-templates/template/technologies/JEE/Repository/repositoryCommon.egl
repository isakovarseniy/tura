[%
/*
 *   Tura - Application generation solution
 *
 *   Copyright (C) 2008-2023 2182342 Ontario Inc ( arseniy.isakov@turasolutions.com ).
 *
 *
 *   This project includes software developed by Arseniy Isakov
 *   https://github.com/isakovarseniy/tura
 *   All rights reserved. This program and the accompanying materials
 *   are made available under the terms of the Eclipse Public License v2.0
 *   which accompanies this distribution, and is available at
 *   http://www.eclipse.org/legal/epl-v20.html
*/
%]
[%
 import "tura:/generation-templates/template/commons/assosiation.eol";

@template
 operation serializer (type, inObj, outObj,model_mapper,recipe,ingredient,trackFields){
     %][%=serializer(type, inObj, outObj,model_mapper,recipe,ingredient,false,trackFields)%][%
  }


@template
 operation serializer (type, inObj, outObj,model_mapper,recipe,ingredient,isCpa,trackFields){
 
         if (trackFields == null){
            trackFields = new Native('java.util.ArrayList');
         }
 
        var util = new Native('org.tura.metamodel.commons.Util');
		for ( field in type.attributes){
		
		     if (type.~skipAttributes.contains(field) or  type.~ignoredAttribute.contains(field)){
		        continue; 
		     }   
		     
		    if ( not isCpa and field.findClassifier(util.getHint(model_mapper,"SignalField"))){
		        continue; 
		    }

            var suffix = ""; 
            if  ( field.pk  and   type.isPersistentInterface(model_mapper)){
               suffix =  type.~class;
            }else{  
			     if ( trackFields.contains(field.name)){
			        continue;
			     }
			     trackFields.add(field.name);
		     }

            var startConverter="";
            var endConverter="";
            if (not isCpa and field.typeRef.isKindOf(type::Enumerator )){
                var enum = field.typeRef; 
                enum.mappingType2Java(recipe,ingredient,'VIEW');
                startConverter = enum.~package+".converter."+enum.~class+"Converter" +".convert(";   
                endConverter = ")";
            }
            
            %][%=outObj%].set[%=util.mergeAndCapitalize(field.name)%][%=suffix%]( [%=startConverter%] [%=inObj%].get[%=util.mergeAndCapitalize(field.name)%][%=suffix%]() [%=endConverter%] );
 			[%}
 			
      var pkg = type.eContainer();
      //var interfaces = type::Generalization.allInstances()->select(t|t.source.uid = type.uid);
      var interfaces = pkg.relationships->select(t|t.isTypeOf(type::Generalization) and  t.source.uid = type.uid);
      
      for (interface in interfaces){
         var tp = interface.target.unwrap();
      %]
      [%=serializer (tp, inObj, outObj,model_mapper,recipe,ingredient,isCpa,trackFields)%]
      [%
      }
 			
 }
 
 
 @template
 operation serializerPK (type, inObj, outObj,model_mapper,recipe,ingredient,trackFields){
     %][%=serializerPK(type, inObj, outObj,model_mapper,recipe,ingredient,false,trackFields)%][%
 }
 
@template
 operation serializerPK (type, inObj, outObj,model_mapper,recipe,ingredient,isCpa,trackFields){
         if (trackFields == null){
            trackFields = new Native('java.util.ArrayList');
         }
        var util = new Native('org.tura.metamodel.commons.Util');
		for ( field in type.attributes){

		     if (type.~skipAttributes.contains(field) or  type.~ignoredAttribute.contains(field)){
		        continue; 
		     }   
		    if ( not isCpa and field.findClassifier(util.getHint(model_mapper,"SignalField"))){
		        continue; 
		    }
		    if (not field.pk){
		      continue;
		    }
		    
            var suffix = ""; 
            if  ( field.pk  and   type.isPersistentInterface(model_mapper)){
               suffix =  type.~class;
            }else{  
			     if ( trackFields.contains(field.name)){
			        continue;
			     }
			     trackFields.add(field.name);
		     }
		
		    
            var startConverter="";
            var endConverter="";
            if (not isCpa and field.typeRef.isKindOf(type::Enumerator )){
                var enum = field.typeRef; 
                enum.mappingType2Java(recipe,ingredient,'VIEW');
                startConverter = enum.~package+".converter."+enum.~class+"Converter" +".convert(";   
                endConverter = ")";
            }
            
            %][%=outObj%].set[%=util.mergeAndCapitalize(field.name)%][%=suffix%]( [%=startConverter%] [%=inObj%].get[%=util.mergeAndCapitalize(field.name)%][%=suffix%]() [%=endConverter%] );
 	    [%
 	    }
 	    
       var pkg = type.eContainer();
 		//var interfaces = type::Generalization.allInstances()->select(t|t.source.uid = type.uid);
 		var interfaces = pkg.relationships->select(t|t.isTypeOf(type::Generalization) and t.source.uid = type.uid);
 		
        for (interface in interfaces){
           var tp = interface.target.unwrap();
        %]
          [%=serializerPK (tp, inObj, outObj,model_mapper,recipe,ingredient,isCpa,trackFields)%]
         [%
       }
 } 
 
  @template
 operation copyLink (type, alltypes, inObj, outObj,model_mapper,recipe,ingredient){
 
      var util = new Native('org.tura.metamodel.commons.Util');
      var pkg = type.eContainer();

	  //var assosiations = type::Assosiation.allInstances()->select(t|t.target.uid = type.uid);
	  var assosiations = pkg.relationships->select(t|t.isTypeOf(type::Assosiation) and t.target.uid = type.uid);
	  
      for (rel in assosiations){
      
         if( "Many2Many".equals(rel.type.toString() )  ){
           continue;
         }
      
		if( not alltypes.contains(rel.source.unwrap())){
               %][%=rel.copyLink(recipe,ingredient,inObj, outObj)%][%
               continue;
		}
		      
         if ( not rel.source.findClassifier(util.getHint(model_mapper,"Entity Object"))  ){
               %][%=rel.copyLink(recipe,ingredient,inObj, outObj)%][%
               continue;
         }
         
         if ( rel.findClassifier(util.getHint(model_mapper,"HideAssosiatioinForJpa"))  ){
               %][%=rel.copyLink(recipe,ingredient,inObj, outObj)%][%
               continue;
         }
         
         
            %][%=rel.copyLinkJpa(recipe,ingredient,inObj, outObj)%][%
      }
      
      var pkg = type.eContainer();
      //var interfaces = type::Generalization.allInstances()->select(t|t.source.uid = type.uid);
      var interfaces = pkg.relationships->select(t|t.isTypeOf(type::Generalization) and t.source.uid = type.uid);
      for (interface in interfaces){
         var tp = interface.target.unwrap();
      %]
      [%=copyLink(tp, alltypes, inObj, outObj,model_mapper,recipe,ingredient)%]
      [%
      }
      
 }
 
 
   @template
 operation type::Assosiation copyLink (recipe,ingredient,inObj, outObj){
      var util = new Native('org.tura.metamodel.commons.Util');
       for ( lnk in  self.links){
        	%][%=outObj%].setTransient[%=util.mergeAndUnCapitalize(lnk.detailField.name)%](  [%=inObj%].get[%=util.mergeAndCapitalize(lnk.detailField.name)%]()  );[%
       }
 }
 
   @template
 operation type::Assosiation copyLinkJpa (recipe,ingredient,inObj, outObj){
      var util = new Native('org.tura.metamodel.commons.Util');
      var hash = self.targetSideNamesCalculation();
      %]
         if ( [%=inObj%].get[%=hash.get("targetMethodName")%]() != null){
      [%
       for ( lnk in  self.links){
        	%][%=outObj%].setTransient[%=util.mergeAndUnCapitalize(lnk.detailField.name)%](  [%=inObj%].get[%=hash.get("targetMethodName")%]().get[%=util.mergeAndCapitalize(lnk.masterField.name)%]()  );[%
       }
      %]
      }
      [%
       
 }
 
 
 @template
 operation saveLink (type, inObj, outObj){
        var util = new Native('org.tura.metamodel.commons.Util');
		for ( field in type.attributes){
		     if (type.~skipAttributes.contains(field) ){
        	%][%=outObj%].setTransient[%=util.mergeAndUnCapitalize(field.name)%](  [%=inObj%].get[%=util.mergeAndCapitalize(field.name)%]()  );[%
		     }else{
		        continue; 
		     }   
        }
      var pkg = type.eContainer();
//      var interfaces = type::Generalization.allInstances()->select(t|t.source.uid = type.uid);
      var interfaces = pkg.relationships->select(t|t.isTypeOf(type::Generalization) and t.source.uid = type.uid);
      for (interface in interfaces){
         var tp = interface.target.unwrap();
      %]
       [%=saveLink(tp, inObj, outObj)%]
      [%
      }        
        
 }
 
  @template
 operation saveLinkCpa (type, inObj, outObj){
        var util = new Native('org.tura.metamodel.commons.Util');
		for ( field in type.attributes){
		     if (type.~skipAttributes.contains(field) ){
        	%][%=outObj%].setTransient[%=util.mergeAndUnCapitalize(field.name)%](  [%=inObj%].getTransient[%=util.mergeAndUnCapitalize(field.name)%]()  );[%
		     }else{
		        continue; 
		     }   
        }
       var pkg = type.eContainer();
//      var interfaces = type::Generalization.allInstances()->select(t|t.source.uid = type.uid);
      var interfaces = pkg.relationships->select(t|t.isTypeOf(type::Generalization) and t.source.uid = type.uid);
      for (interface in interfaces){
         var tp = interface.target.unwrap();
      %]
       [%=saveLinkCpa(tp, inObj, outObj)%]
      [%
      }
 }
 

@template
 operation stringPK (type,name,obj,objFullName){
        var util = new Native('org.tura.metamodel.commons.Util');
 %]
 		  StringBuffer [%=name%] = new StringBuffer();
		  [%for ( field in type.~primaryKey){%]
		   [%=name%].append([%=obj%].get[%=util.mergeAndCapitalize(field.name)%]());
		   [%}%]
		   [%=name%].append("[%=objFullName%]");
 [%
}

@template
 operation nilPK (type,name,model_mapper){
        var util = new Native('org.tura.metamodel.commons.Util');
 %]
		  [%for ( field in type.~primaryKey){
		    if (field.findClassifier(util.getHint(model_mapper,"DoNotNil"))){
		        continue; 
		    }
		  %]
		   [%=name%].set[%=util.mergeAndCapitalize(field.name)%]( null );
		   [%}%]
 [%
}


@template
 operation PK (type,name,obj,objFullName,recipe,ingredient){
    %][%=PK (type,name,obj,objFullName,recipe,ingredient,"")%][%
}

@template
 operation PK (type,name,obj,objFullName,recipe,ingredient,suffix){
       var util = new Native('org.tura.metamodel.commons.Util');
       if(not type.~primaryKey.isDefined() or type.~primaryKey.size()==0){
         util.traceIfDebug("Error","Object "+type.name+" doesn't have primary key");
       }
       if (type.~primaryKey.size()>1){%]
        [%=objFullName%]PK [%=name%] = new  [%=objFullName%]PK();
		  [%for ( field in type.~primaryKey){%]
		   [%=name%].set[%=util.mergeAndCapitalize(field.name)%]( [%=obj%].get[%=suffix%][%=util.mergeAndCapitalize(field.name)%]());
		   [%}
       }else{
          var field = type.~primaryKey.get(0);
          field.typeRef.mappingType2Java(recipe,ingredient);
       %]
        [%=field.typeRef.~fullName%]   [%=name%] =  [%=obj%].get[%=suffix%][%=util.mergeAndCapitalize(field.name)%]();
       [%}
}


@template
 operation PKasSearch (type,name,objFullName,recipe,ingredient){
       var util = new Native('org.tura.metamodel.commons.Util');
       if(not type.~primaryKey.isDefined() or type.~primaryKey.size()==0){
         util.traceIfDebug("Error","Object "+type.name+" doesn't have primary key");
       }
       if (type.~primaryKey.size()>1){%]
        [%=objFullName%]PK [%=name%] = ( [%=objFullName%]PK )pk;
		  [%for ( field in type.~primaryKey){
            field.typeRef.mappingType2Java(recipe,ingredient);
		  %]
		     search.add( new org.tura.platform.datacontrol.commons.SearchCriteria("[%=util.mergeAndCapitalize(field.name)%]",com.octo.java.sql.exp.Operator.EQ.name(),[%=name%].get[%=util.mergeAndCapitalize(field.name)%](),[%=field.typeRef.~fullName%].class.getName()));
		   [%}
       }else{
          var field = type.~primaryKey.get(0);
          field.typeRef.mappingType2Java(recipe,ingredient);
       %]
        [%=field.typeRef.~fullName%]   [%=name%] =  ([%=field.typeRef.~fullName%])pk ;
		search.add( new org.tura.platform.datacontrol.commons.SearchCriteria("[%=util.mergeAndCapitalize(field.name)%]",com.octo.java.sql.exp.Operator.EQ.name(),[%=name%],[%=field.typeRef.~fullName%].class.getName()));
       [%}
}



@template
 operation PKRepoObjectKey(type,name,obj,objFullName,recipe,ingredient){
       var util = new Native('org.tura.metamodel.commons.Util');
       if(not type.~primaryKey.isDefined() or type.~primaryKey.size()==0){
         util.traceIfDebug("Error","Object "+type.name+" doesn't have primary key");
       }
       if (type.~primaryKey.size()>1){%]
        [%=objFullName%]PK [%=name%] = new  [%=objFullName%]PK();
		  [%for ( field in type.~primaryKey){
		            field.typeRef.mappingType2Java(recipe,ingredient);
		  %]
		   [%=name%].set[%=util.mergeAndCapitalize(field.name)%]( ([%=field.typeRef.~fullName%] ) find( "[%=util.mergeAndCapitalize(field.name)%]",[%=obj%]));
		   [%}
       }else{
          var field = type.~primaryKey.get(0);
          field.typeRef.mappingType2Java(recipe,ingredient);
       %]
        [%=field.typeRef.~fullName%]   [%=name%] = ([%=field.typeRef.~fullName%] ) find( "[%=util.mergeAndCapitalize(field.name)%]",[%=obj%]);
       [%}
}



@template
 operation PKDetails (type,name,obj,objFullName,recipe,ingredient,rel){
       var util = new Native('org.tura.metamodel.commons.Util');
       if (type.~primaryKey.size()>1){%]
        [%=objFullName%]PK [%=name%] = new  [%=objFullName%]PK();
		  [%  		for ( lnk in rel.links) {%]
		   [%=name%].set[%=util.mergeAndCapitalize(lnk.masterField.name)%](obj.get[%=util.mergeAndCapitalize(lnk.detailField.name)%]());
		   [%}
       }else{
          var lnk = rel.links.Iterator().next();
          if (lnk == null){
            return;
          }
          var field = lnk.detailField;
          field.typeRef.mappingType2Java(recipe,ingredient);
       %]
        [%=field.typeRef.~fullName%]   [%=name%] =  [%=obj%].get[%=util.mergeAndCapitalize(field.name)%]();
       [%}
}


@template
 operation PKName (type,name,objFullName,recipe,ingredient){
       var util = new Native('org.tura.metamodel.commons.Util');
       if (type.~primaryKey.size()>1){%]
        [%=objFullName%]PK [%=name%]
		[%
       }else{
		  for ( field in type.~primaryKey){
            field.typeRef.mappingType2Java(recipe,ingredient);
		  %]
              [%=field.typeRef.~fullName%]   [%=field.name%]
		   [%}
       %]
       [%}
}
 operation PKType (type,objFullName,recipe,ingredient){
       var util = new Native('org.tura.metamodel.commons.Util');
       if (type.~primaryKey.size()>1){%]
        [%=objFullName%]PK
		[%
       }else{
		  for ( field in type.~primaryKey){
            field.typeRef.mappingType2Java(recipe,ingredient);
		  %]
              [%=field.typeRef.~fullName%] 
		   [%}
       %]
       [%}
}



%]
