[%
/*
 *   Tura - Application generation solution
 *
 *   Copyright (C) 2008-2023 2182342 Ontario Inc ( arseniy.isakov@turasolutions.com ).
 *
 *
 *   This project includes software developed by Arseniy Isakov
 *   https://github.com/isakovarseniy/tura
 *   All rights reserved. This program and the accompanying materials
 *   are made available under the terms of the Eclipse Public License v2.0
 *   which accompanies this distribution, and is available at
 *   http://www.eclipse.org/legal/epl-v20.html
*/
%]
[%
import "tura:/generation-templates/template/commons/typeElementUtil.eol";
import "tura:/generation-templates/template/commons/categorizedUtil.eol";
import "tura:/generation-templates/template/commons/assosiation.eol";
import "tura:/generation-templates/template/technologies/JEE/RepositoryProxy/Serialization/serialCommons.egl";

@template
operation interface(hash){ 
  var util = new Native('org.tura.metamodel.commons.Util');
  
  var recipe = hash.get("recipe");
  var ingredient = hash.get("ingredient");
  var component = hash.get("component");
  var model_mapper = hash.get("model_mapper");
  var path = hash.get("path");
  var type = hash.get("type");
  var mhash =  hash.get("mhash");
  var typeCollection  = hash.get("typeCollection");
  
%] 
package [%=type.~package%]; 

	    [%=jsonTypeInfoAnnotation(type,recipe,ingredient,typeCollection)%]
        public   interface [%=type.~class%]   
[%  
		var i =0; 
		if (type.~interface.isDefined()){
			for (interface in type.~interface ){
			       if(i == 0){
			          %] extends [%
			       }
			       if(i <> 0){%],[%}%] [%=interface.~fullName%] [% 
			       i = 1;
			}
		} 
%]{
		    public Boolean getAttached();
		
		    public void setAttached(Boolean value) ;

[%
     var tp = type;
     for ( field in tp.attributes){
		 
            if ( tp.~ignoredAttribute.contains(field)  ){
                 continue;  
            }
		 
		     field.typeRef.mappingType2Java(recipe,ingredient);
		
		     if (tp.~skipAttributes.contains(field)){ 
		    %] 
		    public  [%=field.typeRef.~fullName%] getTransient[%=util.mergeAndUnCapitalize(field.name)%]();
		    public void setTransient[%=util.mergeAndUnCapitalize(field.name)%]( [%=field.typeRef.~fullName%]  transient[%=util.mergeAndUnCapitalize(field.name)%] );
		    [%
		        continue; 
		     }   
            var suffix = ""; 
            if  ( field.pk  and   tp.isPersistentInterface(model_mapper)){
               suffix =  tp.~class;
            }
		     
		    %]
		    public  [%=field.typeRef.~fullName%] get[%=util.mergeAndCapitalize(field.name)%][%=suffix%]();
		    public void set[%=util.mergeAndCapitalize(field.name)%][%=suffix%]( [%=field.typeRef.~fullName%]  [%=util.mergeAndUnCapitalize(field.name)%][%=suffix%] );
		    
		    [%
			}
			
          var pkg = type.eContainer();
		  //var assosiations = type::Assosiation.allInstances()->select(t|t.source.uid = tp.uid);
		  var assosiations = pkg.relationships->select(t|t.isTypeOf(type::Assosiation) and t.source.uid = tp.uid);
	      for (rel in assosiations){
	      
            var hash = rel.sourceSideNamesCalculation();
            hash.get("source").mappingType2Java(recipe,ingredient);
            hash.get("target").mappingType2Java(recipe,ingredient);
            
	         %]
	         [%
	  	     switch  (rel.type.toString()){
	         case "One2One" : %] public [%=hash.get("target").~fullName%]  get[%=hash.get("sourceMethodName")%]();[%
	         case "One2Many" : %] public java.util.List<[%=hash.get("target").~fullName%]>  get[%=hash.get("sourceMethodName")%]();[%
	         case "Many2Many" : %] public java.util.List<[%=hash.get("target").~fullName%]>  get[%=hash.get("sourceMethodName")%]();[%
	         }                
	         
	  	     switch  (rel.type.toString()){
	         case "One2One" : %] public  void set[%=hash.get("sourceMethodName")%]([%=hash.get("target").~fullName%]  [%=hash.get("sourceProperty")%]);[%
	         case "One2Many" : %] public  void  set[%=hash.get("sourceMethodName")%](java.util.List<[%=hash.get("target").~fullName%]> [%=hash.get("sourceProperty")%]);[%
	         case "Many2Many" : %] public  void  set[%=hash.get("sourceMethodName")%](java.util.List<[%=hash.get("target").~fullName%]> [%=hash.get("sourceProperty")%]);[%
	         }                
	         
	      }
	      

//	  var assosiations = type::Assosiation.allInstances()->select(t|t.target.uid = tp.uid);
	  var assosiations = pkg.relationships->select(t|t.isTypeOf(type::Assosiation) and t.target.uid = tp.uid);
      for (rel in assosiations){
      
         var hash = rel.targetSideNamesCalculation();
         hash.get("source").mappingType2Java(recipe,ingredient);
         hash.get("target").mappingType2Java(recipe,ingredient);
         
  	     switch  (rel.type.toString()){
         case "One2One" : %] public [%=hash.get("source").~fullName%]  get[%=hash.get("targetMethodName")%]();[%
         case "One2Many" : %] public [%=hash.get("source").~fullName%]  get[%=hash.get("targetMethodName")%]();[%
         case "Many2Many" : %] public java.util.List<[%=hash.get("source").~fullName%]>  get[%=hash.get("targetMethodName")%]();[%
         }                

  	     switch  (rel.type.toString()){
         case "One2One" : %] public  void  set[%=hash.get("targetMethodName")%]([%=hash.get("source").~fullName%] [%=hash.get("targetProperty")%]);[%
         case "One2Many" : %] public void set[%=hash.get("targetMethodName")%]([%=hash.get("source").~fullName%] [%=hash.get("targetProperty")%]);[%
         case "Many2Many" : %] public  void set[%=hash.get("targetMethodName")%](java.util.List<[%=hash.get("source").~fullName%]> [%=hash.get("targetProperty")%]);[%
         }                
      }
%]
}
[%}%]
