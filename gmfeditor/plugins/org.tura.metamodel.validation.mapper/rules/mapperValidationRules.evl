 context domain::JavaMapper {

  constraint HasToTypeName {

      check :  self.mappedToClassName.isDefined()

      message :  'Unnamed Maping class ' + self.refName() + ' is not allowed'
  }
  
}


 context domain::JavaScriptMapper {

  constraint HasLibraryUrl {

     check :  self.libraryUrl.isDefined()

     message :  'Undefined stype library url for ' + self.refName() + ' is not allowed'
  }
  
}



 context domain::CSSMapper{
 
  constraint HasStylePackageRef {

      check :  self.stylePackage.isDefined()

      message :  'Undefined stype package  ' + self + ' is not allowed'
  }
 
  constraint HasStyleLibraryRef {

      check :  self.styleLibrary.isDefined()

      message :  'Undefined stype library  ' + self.stylePackage + ' is not allowed'
  }


  constraint HasLibraryUrl {

     guard : self.satisfies("HasStylePackageRef") and self.satisfies("HasStyleLibraryRef") 

     check :  self.libraryUrl.isDefined()

     message :  'Undefined stype library url for ' + self.stylePackage.name+":"+self.styleLibrary.name + ' is not allowed'
  }

 }
 
 
 context domain::RoleMapper{
  
  constraint HasRoleRef {

      check :  self.role.isDefined()

      message :  'Undefined role ' + self.refName() + ' not allowed'
  }
  
  constraint HasLocalRoleName {
     guard : self.satisfies("HasRoleRef")
     check :  self.localRoleName.isDefined()
     message :  'Undefined local role name for Role: ' + self.role.name+ ' not allowed'
  }
  
  constraint HasGlobalRoleName {
     guard : self.satisfies("HasRoleRef")
     check :  self.globalRoleName.isDefined()
     message :  'Undefined global role name for Role: ' + self.role.name + ' not allowed'
  }

}

operation domain::Mapper refName() : String {
     if (self.packageRef <> null  and  self.typeRef <> null ) {
              return self.packageRef.name+":"+self.typeRef.name; }
     else {
          return "NA:NA";
     }
}