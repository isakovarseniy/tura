 context domain::Ingredient {

  constraint HasName {

      check :  self.name.isDefined()

      message : 'Unnamed ' + self.eClass().name + ' not allowed'

  }

  constraint HasLayer {

      guard : self.satisfies("HasName")
      check :  self.layer.isDefined()

      message : 'Unnamed Layer ' + self.name + ' not allowed'

  }


   constraint UniqueName{

      guard : self.satisfies("HasName")
      check : self.parent.ingredients.select(r|r.isKindOf(domain::Ingredient) and r.name=self.name).size() = 1
      message : 'Infrastructure name  ' + self.name + ' is not unique'
   
   } 
}



 context domain::Component {

  constraint HasName {

      check :  self.name.isDefined()

      message : 'Unnamed ' + self.eClass().name + ' not allowed'

  }
}


 context domain::Infrastructure {

  constraint HasName {

      check :  self.name.isDefined()

      message : 'Unnamed ' + self.eClass().name + ' not allowed'

  }
  
 constraint RecipeConnection {

      guard : self.satisfies("HasName")
      check :  self.recipe.isDefined()
      message : 'Infrastructure  ' + self.name + ' disconected from recipe'

  }
   

   constraint UniqueName{

      guard : self.satisfies("RecipeConnection")
      check : self.recipe.infrastructures.select(r|r.isKindOf(Infrastructure) and r.name=self.name).size() = 1
      message : 'Infrastructure name  ' + self.name + ' is not unique'
   
   } 
   
  constraint ConfigVariablesIsDefine {

      check  {
	   var configVar := new Native('org.tura.metamodel.wizard.recipe.configuration.ConfigVarDialog');
	   var properties = configVar.propertiesList(self.recipeConfig);
	   if (properties.size() = 0  )
	      return true;
	   else
	      return false;    
      }

      message : 'Configuration variable  is not defined'

  }   
   
}

context domain::Configuration{

 constraint ConfigurationConnection {

      check :  self.infrastructure.isDefined()
      message : 'Configuration is  disconected from infrastructure'

  }

}


 context domain::ModelMapper {

  constraint HasName {

      check :  self.name.isDefined()

      message : 'Unnamed ' + self.eClass().name + ' not allowed'

  }

   constraint UniqueName{

      guard : self.satisfies("HasName")
      check : self.parent.mappers.select(r|r.isKindOf(ModelMapper) and r.name=self.name).size() = 1
      message : 'ModelMapper name  ' + self.name + ' is not unique'
   
   } 

   constraint HasRefDomainArtifact{
      check : self.domainArtifactRef.isDefined()
      message : 'ModelMapper name  ' + self.name + ' DomainArtifact is not define'
   } 


  constraint HasRefArtifact{
      guard : self.satisfies("HasRefDomainArtifact")
      check : self.artifactRef.isDefined()
      message : 'ModelMapper name  ' + self.name + ' in ' + ' Artifacr  is not define '
   } 

  constraint checkMappingSpecifiers{
      guard : self.satisfies("HasRefArtifact")
      check{
 	   var helper := new Native('org.tura.metamodel.commons.QueryHelper');
	   var result = helper.findMappingSpecifiers(self, self);
	   if (result[0].size()=0 and result[1].size()=0)
	       return true;
	   return false;    
      }
      message : 'MappingSpecifiers   for ' + self.name +  '  is not define  properly'
  }

  constraint checkMappingSpecifiersRef{
      guard : self.satisfies("HasRefArtifact")
      check{
 	   var hash := new Native('java.util.HashMap');
       for( query in self.queries ){
            if ( query.queryRef <> null ){
              hash.put(query.queryRef.uid , query);
         }
       }      
      if (self.artifactRef.modelQuery.size() = hash.size())
        return true;
      return false;
      }
      message : 'Query defined for ' +self.domainArtifactRef.name+'.'+self.artifactRef.name+ ' is exists in ModelMapper '+self.name
  }



}


 context domain::Query {
 
  constraint checkQueryParameters{
      check{
 	   var helper := new Native('org.tura.metamodel.commons.QueryHelper');
	   var result = helper.findMappingVariable(self, self);
	   if (result[0].size()=0 and result[1].size()=0)
	       return true;
	   return false;    
      }
      
      message : 'MappingVariables   for ' + self.name +  '  is not define  properly'

  }
  
  constraint checkQueryParametersName{
      check{
       for (variable in self.variables){
         if (not variable.queryParamRef.isDefined() or variable.queryParamRef.name = "" or variable.queryParamRef.name = null )
             return false;
       }
       return true;
      }  
       message : 'No value for parameter not allowed'
  }  
  
  constraint checkQueryParametersValues{
      guard : self.satisfies("checkQueryParametersName")
      check{
       for (variable in self.variables){
         if (variable.value = null or variable.value = "" )
             return false;
       }
       return true;
      }  
       message : 'No value  not allowed'
  }
}

 context domain::MappingSpecifier {

  constraint HasName {

      check :  self.specifierRef.isDefined()
      message : 'No reference for  Specifier ' + self.eClass().name + ' not allowed'

  }

  constraint HasValue {
  
     check :  self.valueRef.isDefined()
      message : 'No value ' + self.specifierRef.name + ' not allowed'

  }

}


context domain::Property {

  constraint HasName {

      check :  self.confVarRef.isDefined()

      message : 'No reference for Property ' + self.eClass().name + ' not allowed'

  }

  constraint HasValue {

       guard : self.satisfies("HasName")
       check :  self.value.isDefined()

       message : 'No value ' + self.confVarRef.name + ' not allowed'

  }
}
 






