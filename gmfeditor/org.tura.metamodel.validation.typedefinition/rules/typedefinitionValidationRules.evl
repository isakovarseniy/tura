 context domain::Type {

  constraint HasName {

      check :  self.name.isDefined()

      message : 'Unnamed ' + self.eClass().name + ' not allowed'

  }

   constraint UniqueName{

      guard : self.satisfies("HasName")
      check : self.parent.types->select(r|r.isKindOf(domain::Type) and r.name=self.name)->size() = 1
      message : 'Type name  ' + self.name + ' is not unique'
   
   } 

}

 context domain::Primitive {

  constraint HasName {

      check :  self.name.isDefined()

      message : 'Unnamed ' + self.eClass().name + ' not allowed'

  }

   constraint UniqueName{

      guard : self.satisfies("HasName")
      check : self.parent.types.select(r|r.isKindOf(Primitive) and r.name=self.name).size() = 1
      message : 'Type name  ' + self.name + ' is not unique'
   
   } 

}




 context domain::Attribute {

  constraint HasName {

      check :  self.name.isDefined()

      message : 'Unnamed ' + self.eClass().name + ' not allowed'

  }

   constraint UniqueName{

      guard : self.satisfies("HasName")
      check : self.parent.attributes.select(r|r.name=self.name).size() = 1
      message : 'Attribute name  ' + self.name + ' is not unique'
   
   } 
}


 context domain::Parameter {

  constraint HasName {

      check :  self.name.isDefined()

      message : 'Unnamed ' + self.eClass().name + ' not allowed'

  }

   constraint UniqueName{

      guard : self.satisfies("HasName")
      check : self.parent.parameters.select(r|r.name=self.name).size() = 1
      message : 'Parameter name  ' + self.name + ' is not unique'
   
   } 
}


 context domain::Operation {

  constraint HasName {

      check :  self.name.isDefined()

      message : 'Unnamed ' + self.eClass().name + ' not allowed'

  }
   
   constraint UniqueName{

      guard : self.satisfies("HasName")
      check : self.parent.operations.select(r|r.name=self.name).size() = 1
      message : 'Operation name  ' + self.name + ' is not unique'
   
   } 

  constraint ReturnType {

      guard : self.satisfies("UniqueName")
      check :  self.returnValue.isDefined()

      message : 'Undefine return type ' + self.name + ' not allowed'

  }




}

 context domain::Enumarator {

  constraint HasName {

      check :  self.name.isDefined()

      message : 'Unnamed ' + self.eClass().name + ' not allowed'

  }

   constraint UniqueName{

      guard : self.satisfies("HasName")
      check : self.parent.enums.select(r|r.name=self.name).size() = 1
      message : 'Enumarator name  ' + self.name + ' is not unique'
   
   } 

}

 context domain::EnumAttribute {

  constraint HasName {

      check :  self.name.isDefined()

      message : 'Unnamed ' + self.eClass().name + ' not allowed'

  }

  constraint HasValue {

      check :  self.value.isDefined()

      message : 'Empty value for EnumAttribute ' + self.name + ' not allowed'

  }

   constraint UniqueName{

      guard : self.satisfies("HasName")
      check : self.parent.values.select(r|r.name=self.name).size() = 1
      message : 'EnumAttribute name  ' + self.name + ' is not unique'
   
   } 


}

 context domain::TypePointer {

  constraint PackageRef {

      check :  self.packageRef.isDefined()

      message : 'Undefined  package name ' + self.eClass().name + ' not allowed'

  }
  
  constraint TypeRef {

      check :  self.typeRef.isDefined()

      message : 'Undefined  type name ' + self.eClass().name + ' not allowed'

  }

}

 context domain::MethodPointer{
 
   constraint HasName {
      check :  self.methodRef.isDefined()
      message : 'Undefined method name ' + self.eClass().name + ' not allowed'

  }
}





